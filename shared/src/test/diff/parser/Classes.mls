:AllowParseErrors


class Foo
//│ |#class| |Foo|
//│ Parsed: {class Foo() {}}

class Foo {}
//│ |#class| |Foo| |{||}|
//│ Parsed: {class Foo() {}}

class Foo {
  fun foo: int
}
//│ |#class| |Foo| |{|→|#fun| |foo|#:| |int|←|↵|}|
//│ Parsed: {class Foo() {fun foo: [] -> int}}

class Foo {
  class Bar {
    class Baz
  }
}
//│ |#class| |Foo| |{|→|#class| |Bar| |{|→|#class| |Baz|←|↵|}|←|↵|}|
//│ Parsed: {class Foo() {class Bar() {class Baz() {}}}}

class Foo: Bar
//│ |#class| |Foo|#:| |Bar|
//│ Parsed: {class Foo(): Bar {}}

class Foo: Bar, Baz
//│ |#class| |Foo|#:| |Bar|,| |Baz|
//│ Parsed: {class Foo(): Bar, Baz {}}

class Foo: Bar { fun f = 0 }
//│ |#class| |Foo|#:| |Bar| |{| |#fun| |f| |#=| |0| |}|
//│ Parsed: {class Foo(): Bar {fun f = 0}}

class Foo: Bar, Baz { fun f = 0 }
//│ |#class| |Foo|#:| |Bar|,| |Baz| |{| |#fun| |f| |#=| |0| |}|
//│ Parsed: {class Foo(): Bar, Baz {fun f = 0}}

// * Pretty confusing... better reject this:
class Foo: Bar { fun f = 0
  fun bar = 1
}
//│ |#class| |Foo|#:| |Bar| |{| |#fun| |f| |#=| |0|→|#fun| |bar| |#=| |1|←|↵|}|
//│ ╔══[PARSE ERROR] Unexpected 'fun' keyword in expression position
//│ ║  l.44: 	  fun bar = 1
//│ ╙──      	  ^^^
//│ ╔══[PARSE ERROR] Unexpected '=' keyword here
//│ ║  l.44: 	  fun bar = 1
//│ ╙──      	          ^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.43: 	class Foo: Bar { fun f = 0
//│ ║        	                         ^
//│ ║  l.44: 	  fun bar = 1
//│ ╙──      	^^^^^^^^^
//│ Parsed: {class Foo(): Bar {fun f = 0 (bar,)}}

// TODO disallow? (i.e., require unindent before closing brace)
// :e
class Foo: Bar {
  fun f = 0
  fun bar = 1
  }
//│ |#class| |Foo|#:| |Bar| |{|→|#fun| |f| |#=| |0|↵|#fun| |bar| |#=| |1|↵|←|}|
//│ Parsed: {class Foo(): Bar {fun f = 0; fun bar = 1}}

class Foo: Bar {
  fun f = 0
  fun bar = 1
}
//│ |#class| |Foo|#:| |Bar| |{|→|#fun| |f| |#=| |0|↵|#fun| |bar| |#=| |1|←|↵|}|
//│ Parsed: {class Foo(): Bar {fun f = 0; fun bar = 1}}

class Foo: Bar {
  
  fun f = 0
  
  fun bar = 1
  
}
//│ |#class| |Foo|#:| |Bar| |{|→|#fun| |f| |#=| |0|↵|#fun| |bar| |#=| |1|←|↵|}|
//│ Parsed: {class Foo(): Bar {fun f = 0; fun bar = 1}}

class Foo: Bar {
  
}
//│ |#class| |Foo|#:| |Bar| |{|↵|}|
//│ Parsed: {class Foo(): Bar {}}

fun foo =
  class Foo: Bar {
  
  }
//│ |#fun| |foo| |#=|→|#class| |Foo|#:| |Bar| |{|↵|}|←|
//│ Parsed: {fun foo = {class Foo(): Bar {}}}

class Foo()
//│ |#class| |Foo|(||)|
//│ Parsed: {class Foo() {}}

class Foo(x, y, z)
//│ |#class| |Foo|(|x|,| |y|,| |z|)|
//│ Parsed: {class Foo(x, y, z,) {}}


class Foo(x, y, z): Bar(z, x)
//│ |#class| |Foo|(|x|,| |y|,| |z|)|#:| |Bar|(|z|,| |x|)|
//│ Parsed: {class Foo(x, y, z,): Bar (z, x,) {}}

class Foo(x, y, z): Bar(z, x) {
  fun blah(x) = x + y
}
//│ |#class| |Foo|(|x|,| |y|,| |z|)|#:| |Bar|(|z|,| |x|)| |{|→|#fun| |blah|(|x|)| |#=| |x| |+| |y|←|↵|}|
//│ Parsed: {class Foo(x, y, z,): Bar (z, x,) {fun blah = x, => + (x,) (y,)}}

class Foo(x, y): Bar(y, x), Baz(x + y)
//│ |#class| |Foo|(|x|,| |y|)|#:| |Bar|(|y|,| |x|)|,| |Baz|(|x| |+| |y|)|
//│ Parsed: {class Foo(x, y,): Bar (y, x,), Baz (+ (x,) (y,),) {}}

class Foo() {
  public let a = 42
  private fun b = 42
  protected let c = 42
}
//│ |#class| |Foo|(||)| |{|→|#public| |#let| |a| |#=| |42|↵|#private| |#fun| |b| |#=| |42|↵|#protected| |#let| |c| |#=| |42|←|↵|}|
//│ Parsed: {class Foo() {let a = 42; fun b = 42; let c = 42}}


class Bar() {
  private a = 0
}
//│ |#class| |Bar|(||)| |{|→|#private| |a| |#=| |0|←|↵|}|
//│ ╔══[PARSE ERROR] Expected keyword let or fun
//│ ║  l.132: 	  private a = 0
//│ ╙──       	         ^
//│ Parsed: {class Bar() {let a = 0}}

