// recursive functions
:ts
:ne
rec def m a = m
rec def l (a: int) (a: int) = l
//│ m: anything -> 'a as 'a
//│ ts: type 'a = (arg0: unknown) => Recurse<'a>
//│ ts: type Recurse<T> = T
//│ ts: type m = 'a
//│ l: int -> int -> 'a as 'a
//│ ts: type 'a = (arg0: int) => (arg1: int) => Recurse<'a>
//│ ts: type Recurse<T> = T
//│ ts: type l = 'a

// common terms
:ts
:ne
{a = "hello"; b = "world"}
def f a = 2 + 3 - a
def g b = if b.a > 5 then b.a else false
rec def f x = if x == 0 then 1 else x * f (x - 1)
//│ res: {a: "hello", b: "world"}
//│ ts: type res = {a: "hello", b: "world"}
//│ f: int -> int
//│ ts: type f = (arg0: int) => int
//│ g: {a: int & 'a} -> (false | 'a)
//│ ts: type g<'a> = (arg0: {a: int & 'a}) => false | 'a
//│ f: int -> int
//│ ts: type f = (arg0: int) => int

// parametric functions
:ts
:ne
def h c = if c.a > 5 then c.a else c
def h g b = if g b > 4 then "hi" else "bye"
//│ h: ({a: int & 'a} & 'a) -> 'a
//│ ts: type h<'a> = (arg0: {a: int & 'a} & 'a) => 'a
//│ h: ('a -> int) -> 'a -> ("bye" | "hi")
//│ ts: type h<'a> = (arg0: (arg1: 'a) => int) => (arg2: 'a) => "bye" | "hi"