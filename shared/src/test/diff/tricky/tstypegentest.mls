:ts
:ne
{ a = "hello"; b = "world" }
1 + 2 - 5
let t = { a = 5; b = "world"} in if t.a == 1 then 1 else (fun f -> f.b )
def x = 1
def y = 2
def x = x + y
(1, 3, { a = { b = { c = "d"}}}, "hello hello")
// common values
//│ res: {a: "hello", b: "world"}
//│ ts: type res = {a: "hello", b: "world"}
//│ res: int
//│ ts: type res = int
//│ res: {b: 'a} -> 'a | 1
//│ ts: type res<'a> = (arg0: {b: 'a}) => 'a | 1
//│ x: 1
//│ ts: export declare const x: 1
//│ y: 2
//│ ts: export declare const y: 2
//│ x: int
//│ ts: export declare const x: int
//│ res: (1, 3, {a: {b: {c: "d"}}}, "hello hello",)
//│ ts: type res = [1, 3, {a: {b: {c: "d"}}}, "hello hello"]

:ts
:ne
def rcd = { x = 1 }
rcd.x
def funky f r = let t = r with { y = "nah" } in f t
def g = rcd with { y = "yeah "}
// records
//│ rcd: {x: 1}
//│ ts: export declare const rcd: {x: 1}
//│ res: 1
//│ ts: type res = 1
//│ funky: (('a\y & {y: "nah"}) -> 'b) -> 'a -> 'b
//│ ts: export declare const funky<'a, 'b>: (arg0: (arg1: Omit<'a, { y }> & {y: "nah"}) => 'b) => (arg2: 'a) => 'b
//│ g: {x: 1, y: "yeah "}
//│ ts: export declare const g: {x: 1, y: "yeah "}


:ts
:ne
def f (a: int) (b: string) (c: bool) = if bool then a else b
rec def fact x = if x == 1 then 1 else x * fact (x - 1)
// miscellaneous functions
//│ f: int -> string -> bool -> (int | string)
//│ ts: export declare const f: (arg0: int) => (arg1: string) => (arg2: bool) => int | string
//│ fact: int -> int
//│ ts: export declare const fact: (arg0: int) => int

:ts
:ne
rec def l (a: int) = l
rec def m (a: int) (b: int) = m
// recursion type functions
//│ l: int -> 'a as 'a
//│ ts: type 'a = (arg0: int) => 'a
//│ ts: export declare const l: 'a
//│ m: int -> int -> 'a as 'a
//│ ts: type 'a = (arg0: int) => (arg1: int) => 'a
//│ ts: export declare const m: 'a

:ts
:ne
def f x y = if x.a == y.b then x y else fun y -> x
def g = fun x -> fun y -> if x == y then x y else y x
// complex types
//│ f: ('a -> 'b & {a: int} & 'c) -> ({b: int} & 'a) -> (anything -> 'c | 'b)
//│ ts: export declare const f<'a, 'b, 'c>: (arg0: (arg1: 'a) => 'b & {a: int} & 'c) => (arg2: {b: int} & 'a) => (arg3: unknown) => 'c | 'b
//│ g: nothing -> nothing -> nothing
//│ ts: export declare const g: (arg0: never) => (arg1: never) => never


:ts
:ne
def cont x = x + 1
def app y k = k (y - 1)
app 2 cont
//│ cont: int -> int
//│ ts: export declare const cont: (arg0: int) => int
//│ app: int -> (int -> 'a) -> 'a
//│ ts: export declare const app<'a>: (arg0: int) => (arg1: (arg2: int) => 'a) => 'a
//│ res: int
//│ ts: type res = int

:ts
:ne
1: ?
{ a = "hello" }: { a: string } & { b: int }
// type casting and wildcards
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.90: 	1: ?
//│ ║        	^
//│ ╟── integer literal of type `1` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.90: 	1: ?
//│ ╙──      	   ^
//│ res: anything
//│ ts: type res = unknown
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.91: 	{ a = "hello" }: { a: string } & { b: int }
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{a: "hello"}` does not have field 'b'
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.91: 	{ a = "hello" }: { a: string } & { b: int }
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: {a: string, b: int}
//│ ts: type res = {a: string, b: int}

:ts
:ne
type T = int | ~string
def foo: T
def bar: ~T
def gee: T -> { a: int; b: { a: T }}
// negative types
//│ Defined type alias T
//│ foo: int | ~string
//│ ts: type talias1<T0> = T0 extends string ? never : T0
//│ ts: export declare const foo<T0>: int | talias1<T0>
//│ bar: string
//│ ts: export declare const bar: string
//│ gee: (int | ~string) -> {a: int, b: {a: int | ~string}}
//│ ts: type talias4<T3> = T3 extends string ? never : T3
//│ ts: type talias2<T1> = T1 extends string ? never : T1
//│ ts: export declare const gee<T3, T1>: (arg0: int | talias2<T1>) => {a: int, b: {a: int | talias4<T3>}}
