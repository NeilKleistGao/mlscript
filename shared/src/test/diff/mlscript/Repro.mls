
class C
//│ Defined class C

:p
def n: C{}
//│ Parsed: rec def n: [] -> C; {};
//│ Desugared: rec def n: [] -> C
//│ Desugared: {}
//│ n: C
//│  = <missing implementation>
//│ res: anything
//│    = {}


// class G[A]: { a: G[A] & A & G[A] }
class G[A]: { a: G[A] }
//│ Defined class G

def g: G['a] & {a: 'a} as 'a
//│ g: {a: 'a} & G['a] as 'a
//│  = <missing implementation>

:NoJS

// rec def g2 a = G { a }
// :re
rec def g2 = G { a = g2 }
//│ g2: (G['A] with {a: 'a}) as 'a

// g = g2
// :d
// :re
g = g
//│ {a: 'a} & G['a] as 'a
//│   <:  g:
//│ {a: 'a} & G['a] as 'a


def manual: 'a -> nothing as 'a
//│ manual: 'a -> nothing as 'a

:e
manual id
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.44: 	manual id
//│ ║        	^^^^^^^^^
//│ ╟── type `?a -> nothing` does not match type `nothing`
//│ ║  l.40: 	def manual: 'a -> nothing as 'a
//│ ║        	            ^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.40: 	def manual: 'a -> nothing as 'a
//│ ╙──      	                  ^^^^^^^
//│ res: (((nothing & 'd & 'e & 'a,) as 'c) -> ('b | nothing | 'e as 'f) as 'b) | error | nothing | 'd
//│ 	where
//│ 		'a :> (nothing & 'd & 'e) -> ('b | 'e) | 'a -> nothing
//│ 		   <: nothing & 'd & 'e & ((nothing & 'd & 'e) -> ('b | 'e)) -> 'd & 'a -> nothing

// :ds
def manual: 'a -> anything as 'a
//│ manual: 'a -> anything as 'a

manual id
//│ res: ((((anything & 'e & 'f & 'a,) as 'd) -> ('b | 'f as 'g) as 'c) | anything as 'b) | 'e
//│ 	where
//│ 		'a :> (anything & 'e & 'f) -> ('c | 'f) | 'a -> anything
//│ 		   <: anything & 'e & 'f & ((anything & 'e & 'f) -> ('c | 'f)) -> 'e & 'a -> anything

