
def rcd = { x = 1 }
//│ rcd: {x: 1}
//│    = { x: 1 }

rcd.x
//│ res: 1
//│    = 1

rcd with { y = 2 }
//│ res: {x: 1, y: 2}
//│    = { x: 1, y: 2 }

add res.x res.y
//│ res: int
//│    = 3

rcd with { x = "oops" }
//│ res: {x: "oops"}
//│    = { x: 'oops' }

res.x
//│ res: "oops"
//│    = 'oops'

id rcd with { x = "oops" }
//│ res: {x: "oops"}
//│    = { x: 'oops' }

res.x
//│ res: "oops"
//│    = 'oops'


def rcd = { }
//│ rcd: anything
//│    = {}

id rcd with { x = "oops" }
//│ res: {x: "oops"}
//│    = { x: 'oops' }

res.x
//│ res: "oops"
//│    = 'oops'


def f r = r with { x = "oops" }
//│ f: 'a -> ('a\x & {x: "oops"})
//│  = [Function: f]

f rcd
//│ res: {x: "oops"}
//│    = { x: 'oops' }

f (rcd with { y = 2 })
//│ res: {x: "oops", y: 2}
//│    = { y: 2, x: 'oops' }


def f a b = if true then a else b
//│ f: 'a -> 'a -> 'a
//│  = [Function: f1]

def f a b = (if true then a else b) with { x = "oops" }
//│ f: 'a -> 'a -> ('a\x & {x: "oops"})
//│  = [Function: f2]

def f a b = let tmp = a.x in (if true then a else b) with { x = "oops" }
//│ f: ({x: anything} & 'a) -> 'a -> ('a\x & {x: "oops"})
//│  = [Function: f3]


({ name = "Bob" } with { age = 123 }).age
//│ res: 123
//│    = 123

({ name = "Bob" } with { age = 123 }).name
//│ res: "Bob"
//│    = 'Bob'

({ name = "Bob" } with { name = 123 }).name
//│ res: 123
//│    = 123


def getf { f } = f
//│ getf: {f: 'a} -> 'a
//│     = [Function: getf]

def foo x =
  let xf = x with { f = 42 }
  in getf xf
//│ foo: ({f: 'a} | ~{f: 42})\f -> 'a
//│    = [Function: foo]

foo 123
//│ res: 42
//│    = 42

def fooManual: (~{f: 42} | {f: 'a})\f -> 'a
//│ fooManual: ({f: 'a} | ~{f: 42})\f -> 'a
//│          = <missing implementation>

fooManual 123
//│ res: 42
//│    = <no result>
//│      fooManual is not implemented

def foo x =
  let xf = x with { f = 42 }
  in add (getf xf) (getf x)
//│ foo: (({f: int} | ~{f: 42})\f & {f: int}) -> int
//│    = [Function: foo1]

def foo x =
  let xf = x with { f = 42 }
  in { l = getf xf; r = getf x; s = x }
//│ foo: (({f: 'a} | ~{f: 42})\f & {f: 'b} & 'c) -> {l: 'a, r: 'b, s: 'c}
//│    = [Function: foo2]

:e
foo 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.123: 	foo 42
//│ ║         	^^^^^^
//│ ╟── integer literal of type `42` does not have field 'f'
//│ ║  l.123: 	foo 42
//│ ║         	    ^^
//│ ╟── Note: constraint arises from record literal:
//│ ║  l.87: 	def getf { f } = f
//│ ║        	         ^^^^^
//│ ╟── from reference:
//│ ║  l.118: 	  in { l = getf xf; r = getf x; s = x }
//│ ╙──       	                             ^
//│ res: error | {l: 42, r: nothing, s: 42}
//│    = { l: 42, r: undefined, s: 42 }

def r = foo (42 with { f = 1 })
//│ r: {l: 42, r: 1, s: 42 & {f: 1}}
//│  = { l: 42, r: 1, s: [Number: 42] { f: 1 } }

r.s.f
//│ res: 1
//│    = 1

add r.s 1
//│ res: int
//│    = 43


{} with { x = 1 } with { y = 2 }
//│ res: {x: 1, y: 2}
//│    = { x: 1, y: 2 }

:e
res.z
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.157: 	res.z
//│ ║         	^^^^^
//│ ╟── `with` extension of type `{x: 1, y: 2}` does not have field 'z'
//│ ║  l.152: 	{} with { x = 1 } with { y = 2 }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{z: ?a}`
//│ ║  l.157: 	res.z
//│ ╙──       	^^^
//│ res: error
//│    = undefined



// === With and classes === //

class C[A]: { x: A }
//│ Defined class C

c = C{x = 1}
//│ c: C['A .. 1 | 'A] with {x: 1}
//│  = C { x: 1 }

c.x
//│ res: 1
//│    = 1

d = c with { x = "hi"; y = 2 }
//│ d: C['A .. 1 | 'A] with {x: "hi", y: 2}
//│  = C { x: 'hi', y: 2 }

d.x
//│ res: "hi"
//│    = 'hi'

:ds
d: C['a]
//│ Typed as: C[['a3]]
//│  where: A2 :> [[[[[[[[1<int,number>]]]]]]]] | [[[[["hi"<string>]]]]] | [[1<int,number>]] <: [['a3]], 'a3 :> [[[[[1<int,number>]]]]] | [["hi"<string>]] <: [[A2]]
//│ ty[true] C[['a3]]
//│ -> DNF({})
//│ DNF[true] DNF({})
//│ | ty[false] ['a3]
//│ | | Consider 'a3 List([[[[[1<int,number>]]]]], [["hi"<string>]]) List([[A2]])
//│ | | Consider A2 List([[[[[[[[1<int,number>]]]]]]]], [[[[["hi"<string>]]]]], [[1<int,number>]]) List([['a3]])
//│ | -> DNF(A2∧'a3)
//│ | DNF[false] DNF(A2∧'a3)
//│ | | Renewed A2 ~> A4
//│ | | Renewed 'a3 ~> 'a5
//│ | ~> (A4 & 'a5)
//│ | ty[true] ['a3]
//│ | | Consider 'a3 List([[[[[1<int,number>]]]]], [["hi"<string>]]) List([[A2]])
//│ | -> DNF('a3 | 1<int,number>{} | "hi"<string>{})
//│ | DNF[true] DNF('a3 | 1<int,number>{} | "hi"<string>{})
//│ | ~> ("hi"<string> | ('a5 | 1<int,number>))
//│ ~> C[(A4 & 'a5)..("hi"<string> | ('a5 | 1<int,number>))]
//│ Canon: C[(A4 & 'a5)..("hi"<string> | ('a5 | 1<int,number>))]
//│  where: 
//│ [occs] LinkedHashMap((true,'a5) -> HashSet('a5, "hi"<string>, 1<int,number>), (false,'a5) -> HashSet('a5))
//│ [vars] TreeSet(A4, 'a5)
//│ [bounds] 
//│ [rec] HashSet()
//│ /!!!\ Uncaught error: java.lang.AssertionError: assertion failed: A4 has no occurrences...
//│ 	at: scala.Predef$.assert(Predef.scala:279)
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$10(TypeSimplifier.scala:220)
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$10$adapted(TypeSimplifier.scala:213)
//│ 	at: scala.collection.immutable.RedBlackTree$.foreachKey(RedBlackTree.scala:284)
//│ 	at: scala.collection.immutable.TreeSet.foreach(TreeSet.scala:118)
//│ 	at: mlscript.TypeSimplifier.simplifyType(TypeSimplifier.scala:213)
//│ 	at: mlscript.TypeSimplifier.simplifyType$(TypeSimplifier.scala:139)
//│ 	at: mlscript.Typer.simplifyType(Typer.scala:16)
//│ 	at: mlscript.DiffTests.getType$1(DiffTests.scala:275)
//│ 	at: mlscript.DiffTests.$anonfun$new$37(DiffTests.scala:482)

res.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.232: 	res.x
//│ ║         	^^^^^
//│ ╟── string literal of type `"hi"` does not have field 'x'
//│ ║  l.185: 	d = c with { x = "hi"; y = 2 }
//│ ║         	                 ^^^^
//│ ╟── but it flows into reference with expected type `{x: ?a}`
//│ ║  l.232: 	res.x
//│ ╙──       	^^^
//│ res: error
//│    = 'hi'


def f x = (x with { a = 1 }).b
//│ f: ({b: 'a} | ~{a: 1})\a -> 'a
//│  = [Function: f4]

