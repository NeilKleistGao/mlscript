
class Addable[A]
  method Add: A -> A
//│ Defined class Addable
//│ Declared Addable.Add: Addable['A] -> 'A -> 'A

class Num: Addable[Num] & { val: int }
  method Add that = Num { val = this.val + that.val }
//│ Defined class Num
//│ Defined Num.Add: Num -> {val: int} -> Num

class Str: Addable[Str] & { val: string }
  method Add that = Str { val = concat this.val that.val }
//│ Defined class Str
//│ Defined Str.Add: Str -> {val: string} -> Str

n = Num { val = 1 }
//│ n: Num & {val: 1}
//│  = Num { val: 1 }

// TODO-simplif
// :ds
n.Add n
//│ res: Num & {val: 1} | Num
//│    = Num { val: 2 }

n.Add
//│ res: Num -> Num
//│    = [Function: Add]


:ds
def addTwo a0 a1 = a0.Add a1
//│ Typed as: ((..α0',) -> ((..α1',) -> α4'))
//│  where: 
//│ 		α0' <: [[[Addable[A3']]]]
//│ 		α1' <: [[[A3']]]
//│ 		A3' <: [[α4']]
//│ Pols TreeMap(α0' -> Some(false), α1' -> Some(false), A3' -> None, α4' -> None)
//│ Renewed α0' ~> α5'
//│ Renewed A3' ~> A6'
//│ Renewed α4' ~> α7'
//│ Renewed α1' ~> α8'
//│ Cleaned up: ((..α5',) -> ((..α8',) -> α7'))
//│  where: 
//│ 		α5' <: [[[Addable[A6']]]]
//│ 		A6' <: [[α7']]
//│ 		α8' <: [[[A6']]]
//│ ty[+] ((..α5',) -> ((..α8',) -> α7'))
//│ -> Right(DNF(((..α5',) -> ((..α8',) -> α7')){}))
//│ DNF[+] DNF(((..α5',) -> ((..α8',) -> α7')){})
//│ | ty[-] (..α5',)
//│ | -> Right(DNF((..α5',){}))
//│ | DNF[-] DNF((..α5',){})
//│ | | ty[-] α5'
//│ | | | isBadlyRecursive(α5') = None None
//│ | | | Consider α5' List() List([[[Addable[A6']]]])
//│ | | -> Right(DNF({}∧Addable[A6']∧α5'))
//│ | | DNF[-] DNF({}∧Addable[A6']∧α5')
//│ | | | A6' is in a bad place...
//│ | | | Renewed A6' ~> A9'
//│ | | | ty[-] [[α7']]
//│ | | | | isBadlyRecursive(α7') = None None
//│ | | | | Consider α7' List() List()
//│ | | | -> Right(DNF(α7'))
//│ | | | DNF[-] DNF(α7')
//│ | | | | Renewed α7' ~> α10'
//│ | | | ~> α10'
//│ | | | Renewed α5' ~> α11'
//│ | | ~> (Addable[A9'] & α11')
//│ | ~> (..(Addable[A9'] & α11'),)
//│ | ty[+] ((..α8',) -> α7')
//│ | -> Right(DNF(((..α8',) -> α7'){}))
//│ | DNF[+] DNF(((..α8',) -> α7'){})
//│ | | ty[-] (..α8',)
//│ | | -> Right(DNF((..α8',){}))
//│ | | DNF[-] DNF((..α8',){})
//│ | | | ty[-] α8'
//│ | | | | isBadlyRecursive(α8') = None None
//│ | | | | Consider α8' List() List([[[A6']]])
//│ | | | -> Right(DNF(A6'∧α8'))
//│ | | | DNF[-] DNF(A6'∧α8')
//│ | | | | Renewed α8' ~> α12'
//│ | | | ~> (A9' & α12')
//│ | | ~> (..(A9' & α12'),)
//│ | | ty[+] α7'
//│ | | | isBadlyRecursive(α7') = None None
//│ | | | Consider α7' List() List()
//│ | | -> Right(DNF(α7'))
//│ | | DNF[+] DNF(α7')
//│ | | ~> α10'
//│ | ~> ((..(A9' & α12'),) -> α10')
//│ ~> ((..(Addable[A9'] & α11'),) -> ((..(A9' & α12'),) -> α10'))
//│ Canon: ((..(Addable[A9'] & α11'),) -> ((..(A9' & α12'),) -> α10'))
//│  where: 
//│ 		A9' <: α10'
//│ analyze[+] ((..(Addable[A9'] & α11'),) -> ((..(A9' & α12'),) -> α10'))
//│ | analyze[-] (..(Addable[A9'] & α11'),)
//│ | | analyze[-] (Addable[A9'] & α11')
//│ | | | go (Addable[A9'] & α11')   ()
//│ | | | | go Addable[A9']   ()
//│ | | | | | analyze[-] Addable[A9']
//│ | | | | | | analyze[+] A9'
//│ | | | | | | | go A9'   ()
//│ | | | | | | | >>>> A9' HashSet(A9') None
//│ | | | | | | analyze[-] A9'
//│ | | | | | | | go A9'   ()
//│ | | | | | | | | go α10'   (A9')
//│ | | | | | | | >>>> A9' HashSet(A9', α10') None
//│ | | | | | | | >>>> α10' HashSet(A9', α10') None
//│ | | | | go α11'   (Addable[A9'])
//│ | | | >>>> α11' HashSet(Addable[A9'], α11') None
//│ | analyze[+] ((..(A9' & α12'),) -> α10')
//│ | | analyze[-] (..(A9' & α12'),)
//│ | | | analyze[-] (A9' & α12')
//│ | | | | go (A9' & α12')   ()
//│ | | | | | go A9'   ()
//│ | | | | | | go α10'   (A9')
//│ | | | | | go α12'   (A9', α10')
//│ | | | | >>>> A9' HashSet(A9', α10', α12') Some(HashSet(A9', α10'))
//│ | | | | >>>> α10' HashSet(A9', α10', α12') Some(HashSet(A9', α10'))
//│ | | | | >>>> α12' HashSet(A9', α10', α12') None
//│ | | analyze[+] α10'
//│ | | | go α10'   ()
//│ | | | >>>> α10' HashSet(α10') None
//│ [occs] +A9' {A9'} ; -A9' {A9',α10'} ; -α10' {A9',α10'} ; -α11' {Addable[A9'],α11'} ; -α12' {A9',α10',α12'} ; +α10' {α10'}
//│ isBadlyRecursive(A9') = None None
//│ isBadlyRecursive(α10') = None None
//│ isBadlyRecursive(α11') = None None
//│ isBadlyRecursive(α12') = None None
//│ [vars] TreeSet(A9', α10', α11', α12')
//│ [bounds] 
//│ 		A9' <: α10'
//│ [rec] HashSet()
//│ [!] α11'
//│ [!] α12'
//│ [v] A9' Some(HashSet(A9')) Some(HashSet(A9', α10'))
//│ [w] α10' Some(HashSet(A9', α10'))
//│ [U] α10' := A9'
//│ [sub] α10' -> Some(A9'), α11' -> None, α12' -> None
//│ Renewed A9' ~> A13'
//│ Type after simplification: ((..Addable[A13'],) -> ((..A13',) -> A13'))
//│  where: 
//│ 		A13' <: A13'
//│ allVarPols: =A13'
//│ recons[+] ((..Addable[A13'],) -> ((..A13',) -> A13'))  (FunctionType)
//│ | recons[-] (..Addable[A13'],)  (TupleType)
//│ | | recons[-] Addable[A13']  (TypeRef)
//│ | | | recons[=] A13'  (TypeVariable)
//│ | | | | recons[-] A13'  (TypeVariable)
//│ | | | | => A14'
//│ | | | => A14'
//│ | | => Addable[A14']
//│ | => (..Addable[A14'],)
//│ | recons[+] ((..A13',) -> A13')  (FunctionType)
//│ | | recons[-] (..A13',)  (TupleType)
//│ | | | recons[-] A13'  (TypeVariable)
//│ | | | => A14'
//│ | | => (..A14',)
//│ | | recons[+] A13'  (TypeVariable)
//│ | | => A14'
//│ | => ((..A14',) -> A14')
//│ => ((..Addable[A14'],) -> ((..A14',) -> A14'))
//│ Recons: ((..Addable[A14'],) -> ((..A14',) -> A14'))
//│  where: 
//│ 		A14' <: A14'
//│ allVarPols: =A14'
//│ expand[+] ((..Addable[A14'],) -> ((..A14',) -> A14'))  —  
//│ | expand[-] (..Addable[A14'],)  —  
//│ | | expand[-] Addable[A14']  —  
//│ | | | expand[+] ⊥  —  A14'
//│ | | | => Bot
//│ | | | expand[-] A14'  —  A14'
//│ | | | | isBadlyRecursive(A14') = None Some(Some(false))
//│ | | | | (>>>>>>,A14')
//│ | | | | (>>>>>>,Set(A14'),true)
//│ | | | | expand[-] A14'  —  A14'
//│ | | | | => α14
//│ | | | => Inter(α14,α14)
//│ | | => AppliedType(TypeName(Addable),List(α14))
//│ | => Tuple(List((None,Field(None,AppliedType(TypeName(Addable),List(α14))))))
//│ | expand[+] ((..A14',) -> A14')  —  
//│ | | expand[-] (..A14',)  —  
//│ | | | expand[-] A14'  —  
//│ | | | | isBadlyRecursive(A14') = None Some(Some(false))
//│ | | | | (>>>>>>,A14')
//│ | | | | (>>>>>>,Set(),false)
//│ | | | | expand[-] A14'  —  A14'
//│ | | | | => α14
//│ | | | => Inter(α14,α14)
//│ | | => Tuple(List((None,Field(None,Inter(α14,α14)))))
//│ | | expand[+] A14'  —  
//│ | | | isBadlyRecursive(A14') = None Some(Some(false))
//│ | | | (>>>>>>,A14')
//│ | | | (>>>>>>,Set(),false)
//│ | | => α14
//│ | => Function(Tuple(List((None,Field(None,Inter(α14,α14))))),α14)
//│ => Function(Tuple(List((None,Field(None,AppliedType(TypeName(Addable),List(α14)))))),Function(Tuple(List((None,Field(None,Inter(α14,α14))))),α14))
//│ addTwo: Addable['A] -> ('A & 'A) -> 'A
//│ 	where
//│ 		'A <: 'A & 'A
//│       = [Function: addTwo]

addTwo n n
//│ res: Num & {val: 1} | Num
//│    = Num { val: 2 }

s = Str { val = "hey" }
//│ s: Str & {val: "hey"}
//│  = Str { val: 'hey' }

s.Add s
//│ res: Str & {val: "hey"} | Str
//│    = Str { val: 'heyhey' }

addTwo s s
//│ res: Str & {val: "hey"} | Str
//│    = Str { val: 'heyhey' }



def addSame a = a.Add a
//│ addSame: (Addable['A] & 'A & 'A) -> 'A
//│ 	where
//│ 		'A <: 'A & 'A
//│        = [Function: addSame]

addSame n
//│ res: Num & {val: 1} | Num
//│    = Num { val: 2 }


rec def addNTimes a n =
  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ addNTimes: (Addable['A] & 'a & (('a & 'A0 as 'b) as 'A0)) -> int -> 'a
//│ 	where
//│ 		'A <: 'a & 'A & 'b as 'b
//│          = [Function: addNTimes]

addNTimes n 12
//│ res: Num & {val: 1} | Num
//│    = Num { val: 12 }

addNTimes s 5
//│ res: Str & {val: "hey"} | Str
//│    = Str { val: 'heyheyheyheyhey' }




// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors


rec def addNTimes a n =
  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
addNTimes n 12
//│ addNTimes: Addable['A] -> int -> (0 | 'a)
//│ 	where
//│ 		'A :> 0
//│ 		   <: 'a & 'A & 'b as 'b
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+3: 	addNTimes n 12
//│ ║        	^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type Num
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                   ^^^
//│ res: error

rec def addNTimes a n =
  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
addNTimes n 12
//│ addNTimes: (Addable['A] & 'b) -> int -> (0 | 'c) as 'a
//│ 	where
//│ 		'A :> 'a
//│ 		   <: 'b -> int -> 'c
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+3: 	addNTimes n 12
//│ ║        	^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type Num
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                   ^^^
//│ res: error

addSame n n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	addSame n n
//│ ║        	^^^^^^^^^^^
//│ ╟── application of type `Num & {val: ?val}` is not a function
//│ ║  l.17: 	n = Num { val = 1 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `?a -> ?b`
//│ ║  l.+1: 	addSame n n
//│ ╙──      	        ^
//│ res: error

addTwo s n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	addTwo s n
//│ ║        	^^^^^^^^^^
//│ ╟── application of type `Num & {val: ?val}` is not an instance of type Str
//│ ║  l.17: 	n = Num { val = 1 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Str`
//│ ║  l.+1: 	addTwo s n
//│ ║        	         ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from reference:
//│ ║  l.33: 	def addTwo a0 a1 = a0.Add a1
//│ ╙──      	                          ^^
//│ res: error

class Str_bad_0: Addable[Str_bad_0] & { val: string }
  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                                      ^^^^^^^^^^
//│ ╟── type `string` does not match type `int`
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ║        	                                             ^^^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╙──      	                                      ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `string`
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ╙──      	                                             ^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` does not match type `int`
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ║        	                                             ^^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╙──      	                                                 ^^^^^^^^
//│ Defined class Str_bad_0
//│ Defined Str_bad_0.Add: Str_bad_0 -> {val: int} -> (error | (Str_bad_0 with {val: error | int}))

