:NewDefs


:e
module Test<A> {
  fun foo: A => A
}
//│ ╔══[ERROR] Member foo is declared but not defined
//│ ║  l.6: 	  fun foo: A => A
//│ ╙──     	      ^^^
//│ module Test[A]() {
//│   fun foo: A -> A
//│ }

Test.foo
//│ forall 'A. 'A -> 'A
//│ res
//│     = undefined

:re
Test.foo(1)
//│ 1
//│ res
//│ Runtime error:
//│   TypeError: Test.foo is not a function

:re
Test.foo(error) + 1
//│ int
//│ res
//│ Runtime error:
//│   Error: unexpected runtime error

:e
Test<int> .foo
//│ ╔══[ERROR] Type application syntax is not yet supported
//│ ║  l.35: 	Test<int> .foo
//│ ╙──      	^^^^^^^^^
//│ error
//│ res
//│     = undefined

:e
(Test<int>).foo
//│ ╔══[ERROR] Type application syntax is not yet supported
//│ ║  l.44: 	(Test<int>).foo
//│ ╙──      	 ^^^^^^^^^
//│ error
//│ res
//│     = undefined


Test
//│ Test[?]
//│ res
//│     = Test { class: [class Test] }

:e
Test:  Test<'a>
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.59: 	Test:  Test<'a>
//│ ║        	^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.59: 	Test:  Test<'a>
//│ ║        	            ^^
//│ ╟── back into type variable `A`
//│ ║  l.5: 	module Test<A> {
//│ ╙──     	            ^
//│ Test['a]
//│   where
//│     'a :> error | ??A
//│        <: ??A0
//│ res
//│     = Test { class: [class Test] }


fun test(x) = if x is Test then x.foo
//│ fun test: forall 'A. Test['A] -> (forall 'A0. 'A0 -> 'A0)

:e
test(Test)
//│ ╔══[ERROR] Type error in application
//│ ║  l.81: 	test(Test)
//│ ║        	^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.5: 	module Test<A> {
//│ ╙──     	            ^
//│ forall 'A. 'A -> 'A | error
//│ res
//│     = undefined


module Test<A> {
  fun foo = id
}
//│ module Test[A]() {
//│   fun foo: forall 'a. 'a -> 'a
//│ }

Test.foo
//│ forall 'a. 'a -> 'a
//│ res
//│     = [Function: id]


module Test<A> {
  fun foo: A => A
  fun foo = id
}
//│ module Test[A]() {
//│   fun foo: A -> A
//│ }

Test.foo
//│ forall 'A. 'A -> 'A
//│ res
//│     = [Function: id]



