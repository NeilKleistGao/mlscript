:NewDefs


let x: Eql[int]
//│ let x: Eql[int]
//│ x
//│   = <missing implementation>

x === 1
//│ bool
//│ res
//│     = <no result>
//│       x is not implemented

:e
1 === x
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.16: 	1 === x
//│ ║        	^^^^^^^
//│ ╟── type `#Eql & {Eql#A :> int}` is not an instance of type `number`
//│ ║  l.4: 	let x: Eql[int]
//│ ║       	       ^^^^^^^^
//│ ╟── but it flows into reference with expected type `number`
//│ ║  l.16: 	1 === x
//│ ╙──      	      ^
//│ bool | error
//│ res
//│     = <no result>
//│       x is not implemented

:e
x === x
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.32: 	x === x
//│ ║        	^^^^^^^
//│ ╟── type `#Eql & {Eql#A :> int}` is not an instance of type `int`
//│ ║  l.4: 	let x: Eql[int]
//│ ║       	       ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.32: 	x === x
//│ ║        	      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.4: 	let x: Eql[int]
//│ ╙──     	           ^^^
//│ bool | error
//│ res
//│     = <no result>
//│       x is not implemented


fun test1(x) =
  x === x
//│ fun test1: forall 'a. (Eql['a] & 'a) -> bool

fun test2(x, y) =
  x === y
//│ fun test2: forall 'a. (Eql['a], 'a,) -> bool


1 : Eql['a]
//│ Eql[number]
//│ res
//│     = 1

1 : Eql[int]
//│ Eql[int]
//│ res
//│     = 1

1 : Eql[1]
//│ Eql[1]
//│ res
//│     = 1

test1(1)
//│ bool
//│ res
//│     = true


let n: int = 1
//│ let n: int
//│ n
//│   = 1

n : Eql['a]
//│ Eql[number]
//│ res
//│     = 1

test1(n)
//│ bool
//│ res
//│     = true


let n: number
//│ let n: number
//│ n
//│   = <missing implementation>

test1(n)
//│ bool
//│ res
//│     = <no result>
//│       n is not implemented

let d = 1/2
//│ let d: number
//│ d
//│   = 0.5

test1(d)
//│ bool
//│ res
//│     = true

test1("hello")
//│ bool
//│ res
//│     = true


test2(0, 1)
//│ bool
//│ res
//│     = false

test2(0, d)
//│ bool
//│ res
//│     = false

x => test2(0, x)
//│ number -> bool
//│ res
//│     = [Function: res]

x => test2(x, 0)
//│ Eql[0] -> bool
//│ res
//│     = [Function: res]

x => test2(d, x)
//│ number -> bool
//│ res
//│     = [Function: res]

x => test2(x, d)
//│ Eql[number] -> bool
//│ res
//│     = [Function: res]


:e
test2(1, "oops")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.156: 	test2(1, "oops")
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"oops"` is not an instance of type `number`
//│ ║  l.156: 	test2(1, "oops")
//│ ║         	         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.56: 	  x === y
//│ ╙──      	        ^
//│ bool | error
//│ res
//│     = false

:e
test2("oops", 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.171: 	test2("oops", 1)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `string`
//│ ║  l.171: 	test2("oops", 1)
//│ ║         	              ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.56: 	  x === y
//│ ╙──      	        ^
//│ bool | error
//│ res
//│     = false

:e
test2(1, {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.186: 	test2(1, {})
//│ ║         	^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not an instance of type `number`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.56: 	  x === y
//│ ╙──      	        ^
//│ bool | error
//│ res
//│     = false

:e
test2({}, 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.199: 	test2({}, 1)
//│ ║         	^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.56: 	  x === y
//│ ╙──      	  ^
//│ bool | error
//│ res
//│     = false

:e
test2({}, {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	test2({}, {})
//│ ║         	^^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.56: 	  x === y
//│ ╙──      	  ^
//│ bool | error
//│ res
//│     = false


