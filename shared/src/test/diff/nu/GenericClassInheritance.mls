:NewDefs

class Room[A](name: string) {
    fun foo(x: A) = x
}
//│ class Room[A](name: string) {
//│   fun foo: (x: A,) -> A
//│ }

class BigRoom extends Room[bool]("big")
//│ class BigRoom extends Room {
//│   fun foo: (x: 'A,) -> 'A
//│ }
//│ where
//│   'A := bool

// * Note that this essentially infers Room[Bool]
class InferredRoom extends Room("infer") {
    fun foo(x) = x && true
}
//│ class InferredRoom extends Room {
//│   fun foo: bool -> bool
//│ }

(new InferredRoom) : Room['X]
//│ Room[bool]
//│ res
//│     = InferredRoom {}

:e
class TooManyRoom extends Room[int, string]("too many")
//│ ╔══[ERROR] class Room expects 1 type parameter(s); got 2
//│ ║  l.31: 	class TooManyRoom extends Room[int, string]("too many")
//│ ╙──      	                          ^^^^^^^^^^^^^^^^
//│ class TooManyRoom extends Room {
//│   fun foo: (x: 'A,) -> 'A
//│ }
//│ where
//│   'A := int

:e
class WrongRoom extends Room[bool]("wrong") {
    fun foo(x) = x + 1
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.43: 	    fun foo(x) = x + 1
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── type `bool` is not an instance of type `int`
//│ ║  l.42: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	                             ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.43: 	    fun foo(x) = x + 1
//│ ╙──      	                 ^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.43: 	    fun foo(x) = x + 1
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `bool`
//│ ║  l.43: 	    fun foo(x) = x + 1
//│ ║        	                 ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.42: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	                             ^^^^
//│ ╟── from reference:
//│ ║  l.4: 	    fun foo(x: A) = x
//│ ╙──     	                    ^
//│ class WrongRoom extends Room {
//│   fun foo: int -> int
//│ }


class C0[A] { val a: A }
//│ class C0[A] {
//│   let a: A
//│ }

class C1[A] extends C0[A] { val a = a }
//│ class C1[A] extends C0 {
//│   let a: nothing
//│ }

:pe
:e
new C1 : C1[int]
//│ ╔══[PARSE ERROR] Unexpected type ascription after `new` keyword
//│ ║  l.83: 	new C1 : C1[int]
//│ ╙──      	    ^^
//│ ╔══[ERROR] Currently unsupported `new` syntax
//│ ║  l.83: 	new C1 : C1[int]
//│ ╙──      	^^^
//│ error
//│ res
//│     = {}

((new C1) : C1[int]) : C0['X]
//│ C0[int]
//│ res
//│     = C1 {}

(new C1).a
//│ nothing
//│ res
//│     = undefined


mixin M1[A] {
    fun f1(x: A): A = x
    fun f2(x: A): (A, A) = (x, x)
}
//│ mixin M1[A]() {
//│   fun f1: (x: A,) -> A
//│   fun f2: (x: A,) -> (A, A,)
//│ }

class A1 extends M1 {
    fun f1(x: int) = x
}
//│ class A1 {
//│   fun f1: (x: int,) -> int
//│   fun f2: (x: 'A,) -> ('A, 'A,)
//│ }

class A2[S, T] extends M1[(S, T)]
//│ class A2[S, T] {
//│   fun f1: (x: (S, T,),) -> (S, T,)
//│   fun f2: (x: (S, T,),) -> ((S, T,), (S, T,),)
//│ }

class A3(f1: bool => bool) extends M1
//│ class A3(f1: bool -> bool) {
//│   fun f1: (x: 'A,) -> 'A
//│   fun f2: (x: 'A,) -> ('A, 'A,)
//│ }

mixin M2[A] {
    fun m: A = this.a
}
//│ mixin M2[A]() {
//│   this: {a: A}
//│   fun m: A
//│ }

class B1(a: int) extends M2[int]
//│ class B1(a: int) {
//│   fun m: int
//│ }

class B2[A](a: int => A) extends M2
//│ class B2[A](a: int -> A) {
//│   fun m: int -> A
//│ }

:e
class E1(a: int) extends M2[bool]
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.153: 	class E1(a: int) extends M2[bool]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `int` is not an instance of type `bool`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.153: 	class E1(a: int) extends M2[bool]
//│ ║         	                            ^^^^
//│ ╟── from field selection:
//│ ║  l.135: 	    fun m: A = this.a
//│ ╙──       	               ^^^^^^
//│ class E1(a: int) {
//│   fun m: bool
//│ }
