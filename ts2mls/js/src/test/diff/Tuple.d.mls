:NewParser
:ParseOnly
fun key: (string, bool, ) => string
fun value: (string, bool, ) => bool
fun third: (number, number, number, ) => number
fun vec2: number => number => (number, number, )
fun twoFunctions: (number => number, number => number, ) => number => number
fun tupleIt: string => (unit => string, )
fun s: bool => ((string) | (number), (number) | (bool), )
fun s2: (bool, (string) | (number), ) => (string) | (number)
fun ex: T => U => (T, U, (T) & (U), )
fun foo: ((T) & (U), ) => unit
fun conv: (y: number,) => ((y: number,), (z: string,), )
class A() {
  let x: number
}
class B() {}
fun swap: (A, B, ) => (B, A, )
//│ |#fun| |key|#:| |(|string|,| |bool|,| |)| |=>| |string|↵|#fun| |value|#:| |(|string|,| |bool|,| |)| |=>| |bool|↵|#fun| |third|#:| |(|number|,| |number|,| |number|,| |)| |=>| |number|↵|#fun| |vec2|#:| |number| |=>| |number| |=>| |(|number|,| |number|,| |)|↵|#fun| |twoFunctions|#:| |(|number| |=>| |number|,| |number| |=>| |number|,| |)| |=>| |number| |=>| |number|↵|#fun| |tupleIt|#:| |string| |=>| |(|unit| |=>| |string|,| |)|↵|#fun| |s|#:| |bool| |=>| |(|(|string|)| ||| |(|number|)|,| |(|number|)| ||| |(|bool|)|,| |)|↵|#fun| |s2|#:| |(|bool|,| |(|string|)| ||| |(|number|)|,| |)| |=>| |(|string|)| ||| |(|number|)|↵|#fun| |ex|#:| |T| |=>| |U| |=>| |(|T|,| |U|,| |(|T|)| |&| |(|U|)|,| |)|↵|#fun| |foo|#:| |(|(|T|)| |&| |(|U|)|,| |)| |=>| |unit|↵|#fun| |conv|#:| |(|y|#:| |number|,|)| |=>| |(|(|y|#:| |number|,|)|,| |(|z|#:| |string|,|)|,| |)|↵|#class| |A|(||)| |{|→|#let| |x|#:| |number|←|↵|}|↵|#class| |B|(||)| |{||}|↵|#fun| |swap|#:| |(|A|,| |B|,| |)| |=>| |(|B|,| |A|,| |)|
//│ Parsed: {fun key: [] -> (string, bool,) -> string; fun value: [] -> (string, bool,) -> bool; fun third: [] -> (number, number, number,) -> number; fun vec2: [] -> number -> number -> (number, number,); fun twoFunctions: [] -> (number -> number, number -> number,) -> number -> number; fun tupleIt: [] -> string -> (unit -> string,); fun s: [] -> bool -> ((string,) | (number,), (number,) | (bool,),); fun s2: [] -> (bool, (string,) | (number,),) -> ((string,) | (number,)); fun ex: [] -> T -> U -> (T, U, (T,) & (U,),); fun foo: [] -> ((T,) & (U,)) -> unit; fun conv: [] -> (y: number,) -> ((y: number,), (z: string,),); class A() {let x: [] -> number}; class B() {}; fun swap: [] -> (A, B,) -> (B, A,)}
