:NewParser
:ParseOnly
let key: (string, bool, ) => string
let value: (string, bool, ) => bool
let third: (number, number, number, ) => number
let vec2: number => number => (number, number, )
let twoFunctions: (number => number, number => number, ) => number => number
let tupleIt: string => (unit => string, )
let s: bool => ((string) | (number), (number) | (bool), )
let s2: (bool, (string) | (number), ) => (string) | (number)
let ex: T => U => (T, U, (T) & (U), )
let foo: ((T) & (U), ) => unit
let conv: (y: number,) => ((y: number,), (z: string,), )
class A {
  let x: number
}
class B {}
let swap: (A, B, ) => (B, A, )
//│ |#let| |key|#:| |(|string|,| |bool|,| |)| |=>| |string|↵|#let| |value|#:| |(|string|,| |bool|,| |)| |=>| |bool|↵|#let| |third|#:| |(|number|,| |number|,| |number|,| |)| |=>| |number|↵|#let| |vec2|#:| |number| |=>| |number| |=>| |(|number|,| |number|,| |)|↵|#let| |twoFunctions|#:| |(|number| |=>| |number|,| |number| |=>| |number|,| |)| |=>| |number| |=>| |number|↵|#let| |tupleIt|#:| |string| |=>| |(|unit| |=>| |string|,| |)|↵|#let| |s|#:| |bool| |=>| |(|(|string|)| ||| |(|number|)|,| |(|number|)| ||| |(|bool|)|,| |)|↵|#let| |s2|#:| |(|bool|,| |(|string|)| ||| |(|number|)|,| |)| |=>| |(|string|)| ||| |(|number|)|↵|#let| |ex|#:| |T| |=>| |U| |=>| |(|T|,| |U|,| |(|T|)| |&| |(|U|)|,| |)|↵|#let| |foo|#:| |(|(|T|)| |&| |(|U|)|,| |)| |=>| |unit|↵|#let| |conv|#:| |(|y|#:| |number|,|)| |=>| |(|(|y|#:| |number|,|)|,| |(|z|#:| |string|,|)|,| |)|↵|#class| |A| |{|→|#let| |x|#:| |number|←|↵|}|↵|#class| |B| |{||}|↵|#let| |swap|#:| |(|A|,| |B|,| |)| |=>| |(|B|,| |A|,| |)|
//│ Parsed: {let key: [] -> (string, bool,) -> string; let value: [] -> (string, bool,) -> bool; let third: [] -> (number, number, number,) -> number; let vec2: [] -> number -> number -> (number, number,); let twoFunctions: [] -> (number -> number, number -> number,) -> number -> number; let tupleIt: [] -> string -> (unit -> string,); let s: [] -> bool -> ((string,) | (number,), (number,) | (bool,),); let s2: [] -> (bool, (string,) | (number,),) -> ((string,) | (number,)); let ex: [] -> T -> U -> (T, U, (T,) & (U,),); let foo: [] -> ((T,) & (U,)) -> unit; let conv: [] -> (y: number,) -> ((y: number,), (z: string,),); class A() {let x: [] -> number}; class B() {}; let swap: [] -> (A, B,) -> (B, A,)}
