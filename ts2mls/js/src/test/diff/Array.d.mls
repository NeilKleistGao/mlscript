:NewParser
:ParseOnly
fun first: MutArray<string> => string
fun getZero3: unit => MutArray<number>
fun first2: MutArray<number => number> => number => number
fun doEs: MutArray<int> => MutArray<int>
class C {}
trait I {
  let i: number
}
fun doCs: MutArray<C> => MutArray<C>
fun doIs: MutArray<I> => MutArray<I>
fun inter: MutArray<(U) & (T)> => MutArray<(U) & (T)>
fun clean: MutArray<(string, number, )> => MutArray<(string, number, )>
fun translate: MutArray<T> => MutArray<U>
fun uu: MutArray<(number) | (bool)> => MutArray<(number) | (bool)>
class Temp<T> {
  let x: T
}
fun ta: MutArray<Temp<bool>> => MutArray<Temp<bool>>
fun tat: MutArray<Temp<T>> => MutArray<Temp<T>>
//│ |#fun| |first|#:| |MutArray|‹|string|›| |=>| |string|↵|#fun| |getZero3|#:| |unit| |=>| |MutArray|‹|number|›|↵|#fun| |first2|#:| |MutArray|‹|number| |=>| |number|›| |=>| |number| |=>| |number|↵|#fun| |doEs|#:| |MutArray|‹|int|›| |=>| |MutArray|‹|int|›|↵|#class| |C| |{||}|↵|#trait| |I| |{|→|#let| |i|#:| |number|←|↵|}|↵|#fun| |doCs|#:| |MutArray|‹|C|›| |=>| |MutArray|‹|C|›|↵|#fun| |doIs|#:| |MutArray|‹|I|›| |=>| |MutArray|‹|I|›|↵|#fun| |inter|#:| |MutArray|‹|(|U|)| |&| |(|T|)|›| |=>| |MutArray|‹|(|U|)| |&| |(|T|)|›|↵|#fun| |clean|#:| |MutArray|‹|(|string|,| |number|,| |)|›| |=>| |MutArray|‹|(|string|,| |number|,| |)|›|↵|#fun| |translate|#:| |MutArray|‹|T|›| |=>| |MutArray|‹|U|›|↵|#fun| |uu|#:| |MutArray|‹|(|number|)| ||| |(|bool|)|›| |=>| |MutArray|‹|(|number|)| ||| |(|bool|)|›|↵|#class| |Temp|‹|T|›| |{|→|#let| |x|#:| |T|←|↵|}|↵|#fun| |ta|#:| |MutArray|‹|Temp|‹|bool|›|›| |=>| |MutArray|‹|Temp|‹|bool|›|›|↵|#fun| |tat|#:| |MutArray|‹|Temp|‹|T|›|›| |=>| |MutArray|‹|Temp|‹|T|›|›|
//│ Parsed: {fun first: [] -> MutArray[string] -> string; fun getZero3: [] -> unit -> MutArray[number]; fun first2: [] -> MutArray[number -> number] -> number -> number; fun doEs: [] -> MutArray[int] -> MutArray[int]; class C() {}; trait I(): {let i: [] -> number}; fun doCs: [] -> MutArray[C] -> MutArray[C]; fun doIs: [] -> MutArray[I] -> MutArray[I]; fun inter: [] -> MutArray[(U,) & (T,)] -> MutArray[(U,) & (T,)]; fun clean: [] -> MutArray[(string, number,)] -> MutArray[(string, number,)]; fun translate: [] -> MutArray[T] -> MutArray[U]; fun uu: [] -> MutArray[(number,) | (bool,)] -> MutArray[(number,) | (bool,)]; class Temp[T]() {let x: [] -> T}; fun ta: [] -> MutArray[Temp[bool]] -> MutArray[Temp[bool]]; fun tat: [] -> MutArray[Temp[T]] -> MutArray[Temp[T]]}
