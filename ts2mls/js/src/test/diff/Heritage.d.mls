:NewParser
:ParseOnly
class A(foo: unit => unit)
class B: A
class C<T>(set: T => unit, get: unit => T)
class D: C<number>
trait Wu(x: bool)
class WuWu(y: bool): Wu
trait WuWuWu(z: bool): WuWu
trait Never(w: unit => nothing): WuWuWu
class VG<T>(x: T)
class Home<T>(y: T): VG<string>
trait O<I>(xx: I => I)
class OR<R>(xx: R => R): O<R>
namespace Five {
  class Five'ROTK(wu: string)
  class Five'Y: Five'ROTK
}
class Y: Five'ROTK
//│ |#class| |A|(|foo|#:| |unit| |=>| |unit|)|↵|#class| |B|#:| |A|↵|#class| |C|‹|T|›|(|set|#:| |T| |=>| |unit|,| |get|#:| |unit| |=>| |T|)|↵|#class| |D|#:| |C|‹|number|›|↵|#trait| |Wu|(|x|#:| |bool|)|↵|#class| |WuWu|(|y|#:| |bool|)|#:| |Wu|↵|#trait| |WuWuWu|(|z|#:| |bool|)|#:| |WuWu|↵|#trait| |Never|(|w|#:| |unit| |=>| |nothing|)|#:| |WuWuWu|↵|#class| |VG|‹|T|›|(|x|#:| |T|)|↵|#class| |Home|‹|T|›|(|y|#:| |T|)|#:| |VG|‹|string|›|↵|#trait| |O|‹|I|›|(|xx|#:| |I| |=>| |I|)|↵|#class| |OR|‹|R|›|(|xx|#:| |R| |=>| |R|)|#:| |O|‹|R|›|↵|namespace| |Five| |{|→|#class| |Five'ROTK|(|wu|#:| |string|)|↵|#class| |Five'Y|#:| |Five'ROTK|←|↵|}|↵|#class| |Y|#:| |Five'ROTK|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.15: 	namespace Five {
//│ ╙──      	^^^^^^^^^^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found curly brace section instead
//│ ║  l.15: 	namespace Five {
//│ ║        	               ^
//│ ║  l.16: 	  class Five'ROTK(wu: string)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.17: 	  class Five'Y: Five'ROTK
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.18: 	}
//│ ╙──      	^
//│ Parsed: {class A(foo: unit, => unit,) {}; class B(): A {}; class C[T](set: T, => unit, get: unit, => T,) {}; class D(): C‹number› {}; trait Wu(x: bool,): {}; class WuWu(y: bool,): Wu {}; trait WuWuWu(z: bool,): WuWu: {}; trait Never(w: unit, => nothing,): WuWuWu: {}; class VG[T](x: T,) {}; class Home[T](y: T,): VG‹string› {}; trait O[I](xx: I, => I,): {}; class OR[R](xx: R, => R,): O‹R› {}; namespace (Five,)}
