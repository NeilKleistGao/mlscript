:NewParser
:ParseOnly
namespace N1 {
  fun f(_: anything): number
  fun ff(_: anything): number
  class N1'C(f: (): unit)
  trait N1'I(f: (): number)
  namespace N2 {
    fun fff(_: bool): number
    fun gg(_: N1'C): N1'C
    class N1'N2'BBB: N1'C
  }
}
namespace AA {
  fun f(_: anything): string
  class AA'C(f: (): unit)
  trait AA'I(f: (): number)
  namespace N2 {
  }
}
fun f1(_: N1'C): N1'C
fun f2(_: AA'C): AA'C
//│ |namespace| |N1| |{|→|#fun| |f|(|_|#:| |anything|)|#:| |number|↵|#fun| |ff|(|_|#:| |anything|)|#:| |number|↵|#class| |N1'C|(|f|#:| |(||)|#:| |unit|)|↵|#trait| |N1'I|(|f|#:| |(||)|#:| |number|)|↵|namespace| |N2| |{|→|#fun| |fff|(|_|#:| |bool|)|#:| |number|↵|#fun| |gg|(|_|#:| |N1'C|)|#:| |N1'C|↵|#class| |N1'N2'BBB|#:| |N1'C|←|↵|}|←|↵|}|↵|namespace| |AA| |{|→|#fun| |f|(|_|#:| |anything|)|#:| |string|↵|#class| |AA'C|(|f|#:| |(||)|#:| |unit|)|↵|#trait| |AA'I|(|f|#:| |(||)|#:| |number|)|↵|namespace| |N2| |{|↵|}|←|↵|}|↵|#fun| |f1|(|_|#:| |N1'C|)|#:| |N1'C|↵|#fun| |f2|(|_|#:| |AA'C|)|#:| |AA'C|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.3: 	namespace N1 {
//│ ╙──     	^^^^^^^^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found curly brace section instead
//│ ║  l.3: 	namespace N1 {
//│ ║       	             ^
//│ ║  l.4: 	  fun f(_: anything): number
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  fun ff(_: anything): number
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	  class N1'C(f: (): unit)
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.7: 	  trait N1'I(f: (): number)
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	  namespace N2 {
//│ ║       	^^^^^^^^^^^^^^^^
//│ ║  l.9: 	    fun fff(_: bool): number
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.10: 	    fun gg(_: N1'C): N1'C
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.11: 	    class N1'N2'BBB: N1'C
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.12: 	  }
//│ ║        	^^^
//│ ║  l.13: 	}
//│ ╙──      	^
//│ Parsed: {namespace (N1,)}
