:NewParser
:ParseOnly
let extend: T => U => (T) & (U)
let foo: (T) & (U) => unit
let over: (number => string) & (object => string) => string
trait IA {
  let x: number
}
trait IB {
  let y: number
}
let iii: (IA) & (IB) => (IA) & (IB)
let uu: ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P)) => ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P))
let iiii: ((U) & (T)) & (V) => ((U) & (T)) & (V)
let arr: (MutArray<U>) & (MutArray<T>) => (MutArray<U>) & (MutArray<T>)
let tt: ((U, T, )) & ((V, V, )) => ((U, T, )) & ((V, V, ))
class A {}
class B {}
let inter: (A) & (B) => (A) & (B)
//│ |#let| |extend|#:| |T| |=>| |U| |=>| |(|T|)| |&| |(|U|)|↵|#let| |foo|#:| |(|T|)| |&| |(|U|)| |=>| |unit|↵|#let| |over|#:| |(|number| |=>| |string|)| |&| |(|object| |=>| |string|)| |=>| |string|↵|#trait| |IA| |{|→|#let| |x|#:| |number|←|↵|}|↵|#trait| |IB| |{|→|#let| |y|#:| |number|←|↵|}|↵|#let| |iii|#:| |(|IA|)| |&| |(|IB|)| |=>| |(|IA|)| |&| |(|IB|)|↵|#let| |uu|#:| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)| |=>| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|↵|#let| |iiii|#:| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)| |=>| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|↵|#let| |arr|#:| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)| |=>| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|↵|#let| |tt|#:| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)| |=>| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|↵|#class| |A| |{||}|↵|#class| |B| |{||}|↵|#let| |inter|#:| |(|A|)| |&| |(|B|)| |=>| |(|A|)| |&| |(|B|)|
//│ Parsed: {let extend: [] -> T -> U -> ((T,) & (U,)); let foo: [] -> ((T,) & (U,)) -> unit; let over: [] -> ((number -> string,) & (object -> string,)) -> string; trait IA(): {let x: [] -> number}; trait IB(): {let y: [] -> number}; let iii: [] -> ((IA,) & (IB,)) -> ((IA,) & (IB,)); let uu: [] -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)) -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)); let iiii: [] -> (((U,) & (T,),) & (V,)) -> (((U,) & (T,),) & (V,)); let arr: [] -> ((MutArray[U],) & (MutArray[T],)) -> ((MutArray[U],) & (MutArray[T],)); let tt: [] -> (((U, T,),) & ((V, V,),)) -> (((U, T,),) & ((V, V,),)); class A() {}; class B() {}; let inter: [] -> ((A,) & (B,)) -> ((A,) & (B,))}
