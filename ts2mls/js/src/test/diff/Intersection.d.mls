:NewParser
:ParseOnly
let extend: (T) => ((U) => ((T) & (U)))
let foo: ((T) & (U)) => (unit)
let over: (((number) => (string)) & ((object) => (string))) => (string)
trait IA(x: number)
trait IB(y: number)
let iii: ((IA) & (IB)) => ((IA) & (IB))
let uu: (((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P))) => (((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P)))
let iiii: (((U) & (T)) & (V)) => (((U) & (T)) & (V))
let arr: ((MutArray<U>) & (MutArray<T>)) => ((MutArray<U>) & (MutArray<T>))
let tt: (((U, T, )) & ((V, V, ))) => (((U, T, )) & ((V, V, )))
class A
class B
let inter: ((A) & (B)) => ((A) & (B))
//│ |#let| |extend|#:| |(|T|)| |=>| |(|(|U|)| |=>| |(|(|T|)| |&| |(|U|)|)|)|↵|#let| |foo|#:| |(|(|T|)| |&| |(|U|)|)| |=>| |(|unit|)|↵|#let| |over|#:| |(|(|(|number|)| |=>| |(|string|)|)| |&| |(|(|object|)| |=>| |(|string|)|)|)| |=>| |(|string|)|↵|#trait| |IA|(|x|#:| |number|)|↵|#trait| |IB|(|y|#:| |number|)|↵|#let| |iii|#:| |(|(|IA|)| |&| |(|IB|)|)| |=>| |(|(|IA|)| |&| |(|IB|)|)|↵|#let| |uu|#:| |(|(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|)| |=>| |(|(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|)|↵|#let| |iiii|#:| |(|(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|)| |=>| |(|(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|)|↵|#let| |arr|#:| |(|(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|)| |=>| |(|(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|)|↵|#let| |tt|#:| |(|(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|)| |=>| |(|(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|)|↵|#class| |A|↵|#class| |B|↵|#let| |inter|#:| |(|(|A|)| |&| |(|B|)|)| |=>| |(|(|A|)| |&| |(|B|)|)|
//│ Parsed: {fun extend: [] -> T -> (U -> ((T,) & (U,),),); fun foo: [] -> ((T,) & (U,)) -> (unit,); fun over: [] -> ((number -> (string,),) & (object -> (string,),)) -> (string,); trait IA(x: number,): {}; trait IB(y: number,): {}; fun iii: [] -> ((IA,) & (IB,)) -> ((IA,) & (IB,),); fun uu: [] -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)) -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),),); fun iiii: [] -> (((U,) & (T,),) & (V,)) -> (((U,) & (T,),) & (V,),); fun arr: [] -> ((MutArray[U],) & (MutArray[T],)) -> ((MutArray[U],) & (MutArray[T],),); fun tt: [] -> (((U, T,),) & ((V, V,),)) -> (((U, T,),) & ((V, V,),),); class A() {}; class B() {}; fun inter: [] -> ((A,) & (B,)) -> ((A,) & (B,),)}
