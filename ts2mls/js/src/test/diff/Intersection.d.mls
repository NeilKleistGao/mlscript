:NewParser
:ParseOnly
fun extend<T, U>(v0: T, v1: U): (T) & (U)
fun foo<T, U>(v0: (T) & (U)): unit
fun over(v0: (number => string) & (object => string)): string
trait IA() {
  let x: number
}
trait IB() {
  let y: number
}
fun iii(v0: (IA) & (IB)): (IA) & (IB)
fun uu<U, V, T, P>(v0: ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P))): ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P))
fun iiii<U, T, V>(v0: ((U) & (T)) & (V)): ((U) & (T)) & (V)
fun arr<U, T>(v0: (MutArray<U>) & (MutArray<T>)): (MutArray<U>) & (MutArray<T>)
fun tt<U, T, V>(v0: ((U, T, )) & ((V, V, ))): ((U, T, )) & ((V, V, ))
class A() {}
class B() {}
fun inter(v0: (A) & (B)): (A) & (B)
//│ |#fun| |extend|‹|T|,| |U|›|(|v0|#:| |T|,| |v1|#:| |U|)|#:| |(|T|)| |&| |(|U|)|↵|#fun| |foo|‹|T|,| |U|›|(|v0|#:| |(|T|)| |&| |(|U|)|)|#:| |unit|↵|#fun| |over|(|v0|#:| |(|number| |=>| |string|)| |&| |(|object| |=>| |string|)|)|#:| |string|↵|#trait| |IA|(||)| |{|→|#let| |x|#:| |number|←|↵|}|↵|#trait| |IB|(||)| |{|→|#let| |y|#:| |number|←|↵|}|↵|#fun| |iii|(|v0|#:| |(|IA|)| |&| |(|IB|)|)|#:| |(|IA|)| |&| |(|IB|)|↵|#fun| |uu|‹|U|,| |V|,| |T|,| |P|›|(|v0|#:| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|)|#:| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|↵|#fun| |iiii|‹|U|,| |T|,| |V|›|(|v0|#:| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|)|#:| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|↵|#fun| |arr|‹|U|,| |T|›|(|v0|#:| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|)|#:| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|↵|#fun| |tt|‹|U|,| |T|,| |V|›|(|v0|#:| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|)|#:| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|↵|#class| |A|(||)| |{||}|↵|#class| |B|(||)| |{||}|↵|#fun| |inter|(|v0|#:| |(|A|)| |&| |(|B|)|)|#:| |(|A|)| |&| |(|B|)|
//│ Parsed: {fun extend: [] -> (v0: T, v1: U,) -> ((T,) & (U,)); fun foo: [] -> (v0: (T,) & (U,),) -> unit; fun over: [] -> (v0: (number -> string,) & (object -> string,),) -> string; trait IA(): {let x: [] -> number}; trait IB(): {let y: [] -> number}; fun iii: [] -> (v0: (IA,) & (IB,),) -> ((IA,) & (IB,)); fun uu: [] -> (v0: ((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),),) -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)); fun iiii: [] -> (v0: ((U,) & (T,),) & (V,),) -> (((U,) & (T,),) & (V,)); fun arr: [] -> (v0: (MutArray[U],) & (MutArray[T],),) -> ((MutArray[U],) & (MutArray[T],)); fun tt: [] -> (v0: ((U, T,),) & ((V, V,),),) -> (((U, T,),) & ((V, V,),)); class A() {}; class B() {}; fun inter: [] -> (v0: (A,) & (B,),) -> ((A,) & (B,))}
