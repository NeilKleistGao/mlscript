:NewParser
:ParseOnly
fun extend: T => U => (T) & (U)
fun foo: (T) & (U) => unit
fun over: (number => string) & (object => string) => string
trait IA() {
  let x: number
}
trait IB() {
  let y: number
}
fun iii: (IA) & (IB) => (IA) & (IB)
fun uu: ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P)) => ((((U) & (T)) | ((U) & (P))) | ((V) & (T))) | ((V) & (P))
fun iiii: ((U) & (T)) & (V) => ((U) & (T)) & (V)
fun arr: (MutArray<U>) & (MutArray<T>) => (MutArray<U>) & (MutArray<T>)
fun tt: ((U, T, )) & ((V, V, )) => ((U, T, )) & ((V, V, ))
class A() {}
class B() {}
fun inter: (A) & (B) => (A) & (B)
//│ |#fun| |extend|#:| |T| |=>| |U| |=>| |(|T|)| |&| |(|U|)|↵|#fun| |foo|#:| |(|T|)| |&| |(|U|)| |=>| |unit|↵|#fun| |over|#:| |(|number| |=>| |string|)| |&| |(|object| |=>| |string|)| |=>| |string|↵|#trait| |IA|(||)| |{|→|#let| |x|#:| |number|←|↵|}|↵|#trait| |IB|(||)| |{|→|#let| |y|#:| |number|←|↵|}|↵|#fun| |iii|#:| |(|IA|)| |&| |(|IB|)| |=>| |(|IA|)| |&| |(|IB|)|↵|#fun| |uu|#:| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)| |=>| |(|(|(|(|U|)| |&| |(|T|)|)| ||| |(|(|U|)| |&| |(|P|)|)|)| ||| |(|(|V|)| |&| |(|T|)|)|)| ||| |(|(|V|)| |&| |(|P|)|)|↵|#fun| |iiii|#:| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)| |=>| |(|(|U|)| |&| |(|T|)|)| |&| |(|V|)|↵|#fun| |arr|#:| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)| |=>| |(|MutArray|‹|U|›|)| |&| |(|MutArray|‹|T|›|)|↵|#fun| |tt|#:| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)| |=>| |(|(|U|,| |T|,| |)|)| |&| |(|(|V|,| |V|,| |)|)|↵|#class| |A|(||)| |{||}|↵|#class| |B|(||)| |{||}|↵|#fun| |inter|#:| |(|A|)| |&| |(|B|)| |=>| |(|A|)| |&| |(|B|)|
//│ Parsed: {fun extend: [] -> T -> U -> ((T,) & (U,)); fun foo: [] -> ((T,) & (U,)) -> unit; fun over: [] -> ((number -> string,) & (object -> string,)) -> string; trait IA(): {let x: [] -> number}; trait IB(): {let y: [] -> number}; fun iii: [] -> ((IA,) & (IB,)) -> ((IA,) & (IB,)); fun uu: [] -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)) -> (((((U,) & (T,),) | ((U,) & (P,),),) | ((V,) & (T,),),) | ((V,) & (P,),)); fun iiii: [] -> (((U,) & (T,),) & (V,)) -> (((U,) & (T,),) & (V,)); fun arr: [] -> ((MutArray[U],) & (MutArray[T],)) -> ((MutArray[U],) & (MutArray[T],)); fun tt: [] -> (((U, T,),) & ((V, V,),)) -> (((U, T,),) & ((V, V,),)); class A() {}; class B() {}; fun inter: [] -> ((A,) & (B,)) -> ((A,) & (B,))}
