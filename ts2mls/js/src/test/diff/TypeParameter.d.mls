:NewParser
:ParseOnly
fun inc<T>(_: T): number
class CC<T>() {
  fun print: T => unit
}
fun con<U, T>(_: T): U
class Printer<T>() {
  fun print: T => unit
}
fun setStringPrinter(_: Printer<string>): unit
fun getStringPrinter(): Printer<string>
fun foo<T>(_: Printer<T>, _: T): T
fun foo2<T>(_: Printer<T>, _: T): T
class F<T>() {
  let x: T
  fun GG: U => T
}
trait I<T>() {
  let x: T
  fun GG: U => T
}
class FFF<T>() {
  fun fff: T => unit
}
fun fff(_: FFF<string>, _: string): unit
fun getFFF(): FFF<number>
//│ |#fun| |inc|‹|T|›|(|_|#:| |T|)|#:| |number|↵|#class| |CC|‹|T|›|(||)| |{|→|#fun| |print|#:| |T| |=>| |unit|←|↵|}|↵|#fun| |con|‹|U|,| |T|›|(|_|#:| |T|)|#:| |U|↵|#class| |Printer|‹|T|›|(||)| |{|→|#fun| |print|#:| |T| |=>| |unit|←|↵|}|↵|#fun| |setStringPrinter|(|_|#:| |Printer|‹|string|›|)|#:| |unit|↵|#fun| |getStringPrinter|(||)|#:| |Printer|‹|string|›|↵|#fun| |foo|‹|T|›|(|_|#:| |Printer|‹|T|›|,| |_|#:| |T|)|#:| |T|↵|#fun| |foo2|‹|T|›|(|_|#:| |Printer|‹|T|›|,| |_|#:| |T|)|#:| |T|↵|#class| |F|‹|T|›|(||)| |{|→|#let| |x|#:| |T|↵|#fun| |GG|#:| |U| |=>| |T|←|↵|}|↵|#trait| |I|‹|T|›|(||)| |{|→|#let| |x|#:| |T|↵|#fun| |GG|#:| |U| |=>| |T|←|↵|}|↵|#class| |FFF|‹|T|›|(||)| |{|→|#fun| |fff|#:| |T| |=>| |unit|←|↵|}|↵|#fun| |fff|(|_|#:| |FFF|‹|string|›|,| |_|#:| |string|)|#:| |unit|↵|#fun| |getFFF|(||)|#:| |FFF|‹|number|›|
//│ Parsed: {fun inc: [] -> (_: T,) -> number; class CC[T]() {fun print: [] -> T -> unit}; fun con: [] -> (_: T,) -> U; class Printer[T]() {fun print: [] -> T -> unit}; fun setStringPrinter: [] -> (_: Printer[string],) -> unit; fun getStringPrinter: [] -> () -> Printer[string]; fun foo: [] -> (_: Printer[T], _: T,) -> T; fun foo2: [] -> (_: Printer[T], _: T,) -> T; class F[T]() {let x: [] -> T; fun GG: [] -> U -> T}; trait I[T](): {let x: [] -> T; fun GG: [] -> U -> T}; class FFF[T]() {fun fff: [] -> T -> unit}; fun fff: [] -> (_: FFF[string], _: string,) -> unit; fun getFFF: [] -> () -> FFF[number]}
