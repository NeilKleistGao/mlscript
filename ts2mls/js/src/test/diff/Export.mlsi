:NewParser
:NewDefs
:NoJS
:AllowTypeErrors
import "./Dependency.mlsi"
export declare module Export {
  export module Foo {
    fun Baz(aa: string): IBar
    trait IBar {
      val a: string
    }
    export class Bar extends IBar {
      val a: string
    }
    export val baz: IBar
  }
  fun default(x: anything): anything
  export class E {}
  export type F = E
  export type G = Dependency.B
  export type H = Dependency
}
//│ ╔══[ERROR] type identifier not found: IBar
//│ ║  l.8: 	    fun Baz(aa: string): IBar
//│ ╙──     	                         ^^^^
//│ ╔══[ERROR] traits are not yet supported
//│ ║  l.9: 	    trait IBar {
//│ ║       	    ^^^^^^^^^^^^
//│ ║  l.10: 	      val a: string
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.11: 	    }
//│ ╙──      	^^^^^
//│ ╔══[ERROR] Cannot inherit from a type alias
//│ ║  l.12: 	    export class Bar extends IBar {
//│ ╙──      	                             ^^^^
//│ ╔══[ERROR] trait IBar cannot be used as a type
//│ ║  l.15: 	    export val baz: IBar
//│ ╙──      	                    ^^^^
//│ ╔══[ERROR] Member Baz is declared but not defined
//│ ║  l.8: 	    fun Baz(aa: string): IBar
//│ ╙──     	        ^^^
//│ ╔══[ERROR] type identifier not found: Dependency
//│ ║  l.20: 	  export type G = Dependency.B
//│ ╙──      	                  ^^^^^^^^^^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:205)
//│ 	at: mlscript.utils.package$.die(package.scala:204)
//│ 	at: mlscript.ConstraintSolver.$anonfun$lookupMember$1(ConstraintSolver.scala:34)
//│ 	at: scala.collection.mutable.HashMap.getOrElse(HashMap.scala:436)
//│ 	at: mlscript.ConstraintSolver.lookupMember(ConstraintSolver.scala:34)
//│ 	at: mlscript.Typer.go$1(Typer.scala:490)
//│ 	at: mlscript.Typer.$anonfun$typeType2$11(Typer.scala:503)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.Typer.rec$1(Typer.scala:547)
//│ 	at: mlscript.Typer.$anonfun$typeType2$2(Typer.scala:548)
