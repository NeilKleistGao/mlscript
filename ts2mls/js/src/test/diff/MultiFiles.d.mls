:NewParser
:ParseOnly
fun multi1: number => number
fun multi3: unit => unit
class Foo(): Base {}
trait AnotherBase {
  let y: string
}
namespace N {
  fun f: unit => unit
  fun g: unit => unit
  fun h: unit => unit
}
fun multi2: string => string
fun multi4: unit => unit
trait Base {
  let a: number
}
class AnotherFoo(): AnotherBase {}
fun multi5: unit => unit
//│ |#fun| |multi1|#:| |number| |=>| |number|↵|#fun| |multi3|#:| |unit| |=>| |unit|↵|#class| |Foo|(||)|#:| |Base| |{||}|↵|#trait| |AnotherBase| |{|→|#let| |y|#:| |string|←|↵|}|↵|#namespace| |N| |{|→|#fun| |f|#:| |unit| |=>| |unit|↵|#fun| |g|#:| |unit| |=>| |unit|↵|#fun| |h|#:| |unit| |=>| |unit|←|↵|}|↵|#fun| |multi2|#:| |string| |=>| |string|↵|#fun| |multi4|#:| |unit| |=>| |unit|↵|#trait| |Base| |{|→|#let| |a|#:| |number|←|↵|}|↵|#class| |AnotherFoo|(||)|#:| |AnotherBase| |{||}|↵|#fun| |multi5|#:| |unit| |=>| |unit|
//│ Parsed: {fun multi1: [] -> number -> number; fun multi3: [] -> unit -> unit; class Foo(): Base {}; trait AnotherBase(): {let y: [] -> string}; namespace N(): {fun f: [] -> unit -> unit; fun g: [] -> unit -> unit; fun h: [] -> unit -> unit}; fun multi2: [] -> string -> string; fun multi4: [] -> unit -> unit; trait Base(): {let a: [] -> number}; class AnotherFoo(): AnotherBase {}; fun multi5: [] -> unit -> unit}
