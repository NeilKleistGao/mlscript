:NewParser
:ParseOnly
let multi1: number => number
let multi3: unit => unit
class Foo(): Base {}
trait AnotherBase {
  let y: string
}
namespace N {
  let f: unit => unit
  let g: unit => unit
  let h: unit => unit
}
let multi2: string => string
let multi4: unit => unit
trait Base {
  let a: number
}
class AnotherFoo(): AnotherBase {}
let multi5: unit => unit
//│ |#let| |multi1|#:| |number| |=>| |number|↵|#let| |multi3|#:| |unit| |=>| |unit|↵|#class| |Foo|(||)|#:| |Base| |{||}|↵|#trait| |AnotherBase| |{|→|#let| |y|#:| |string|←|↵|}|↵|#namespace| |N| |{|→|#let| |f|#:| |unit| |=>| |unit|↵|#let| |g|#:| |unit| |=>| |unit|↵|#let| |h|#:| |unit| |=>| |unit|←|↵|}|↵|#let| |multi2|#:| |string| |=>| |string|↵|#let| |multi4|#:| |unit| |=>| |unit|↵|#trait| |Base| |{|→|#let| |a|#:| |number|←|↵|}|↵|#class| |AnotherFoo|(||)|#:| |AnotherBase| |{||}|↵|#let| |multi5|#:| |unit| |=>| |unit|
//│ Parsed: {fun multi1: [] -> number -> number; fun multi3: [] -> unit -> unit; class Foo(): Base {}; trait AnotherBase(): {fun y: [] -> string}; namespace N(): {fun f: [] -> unit -> unit; fun g: [] -> unit -> unit; fun h: [] -> unit -> unit}; fun multi2: [] -> string -> string; fun multi4: [] -> unit -> unit; trait Base(): {fun a: [] -> number}; class AnotherFoo(): AnotherBase {}; fun multi5: [] -> unit -> unit}
