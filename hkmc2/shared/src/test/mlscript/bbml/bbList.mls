:global
:bbml



class List[A](inspect: [E, Res] -> (() ->{E} Res, (A, List[A]) ->{E} Res) ->{E} Res)
//│ Type: ⊤

fun map: [A, B, E] -> List[out A] -> (A ->{E} B) ->{E} List[out B]
//│ Type: ⊤


// * Dummy implementation
fun mapi: [A, E] -> List[out A] -> ((Int, A) ->{E} A) ->{Alloc | E} List[out A]
fun mapi = s => f =>
  region r in
    map(s) of x => f(0, x)
//│ Type: ⊤

fun mapi: [A, E] -> List[out A] -> ((Int, A) ->{E} A) ->{Alloc | E} List[out A]
fun mapi = s => f =>
  region r in
    let i = r.ref 0
    map(s) of x =>
      i := !i + 1
      f(!i, x)
//│ Type: ⊤

// * Example usage

fun mkList: [A] -> A -> List[out A]
fun head: [A] -> List[out A] -> A
//│ Type: ⊤

region r in
  let sum = r.ref 0
  let s1 = mkList of !sum
  let s2 = mapi(s1) of (x, i) => x * i
  !sum + head(s2)
//│ Type: Int


// * Should be an error. This definition would not be referentially transparent.
// * The error message needs improvement, though.
:e
fun mapi: [A, E] -> List[out A] -> ((Int, A) ->{E} A) ->{Alloc | E} List[out A]
fun mapi = s =>
  region r in
    let i = r.ref 0
    f => map(s) of x =>
      i := !i + 1
      f(!i, x)
//│ ╔══[ERROR] Type error in function literal with expected type (List[out <α>58_2]) ->{⊥} ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ║  l.47: 	fun mapi = s =>
//│ ║        	           ^^^^
//│ ║  l.48: 	  region r in
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.49: 	    let i = r.ref 0
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.50: 	    f => map(s) of x =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.51: 	      i := !i + 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.52: 	      f(!i, x)
//│ ║        	^^^^^^^^^^^^^^
//│ ╙── because: cannot constrain  α73_2 ∨ <α>0_0  <:  ⊥
//│ ╔══[ERROR] Type error in function literal with expected type (List[out <α>58_2]) ->{⊥} ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ║  l.47: 	fun mapi = s =>
//│ ║        	           ^^^^
//│ ║  l.48: 	  region r in
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.49: 	    let i = r.ref 0
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.50: 	    f => map(s) of x =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.51: 	      i := !i + 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.52: 	      f(!i, x)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α74_2 ->{α82_2} List[out α81_2]  <:  ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α82_2) ∨ ⊥  <:  (((⊤ ∧ ⊤) ∧ <α>0_0) ∨ ((⊤ ∧ ⊤) ∧ <α>59_2)) ∨ ⊥
//│ ╟── because: cannot constrain  α82_2  <:  <α>59_2 ∨ <α>0_0
//│ ╟── because: cannot constrain  α83_2  <:  <α>59_2 ∨ <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>59_2 ∨ <α>0_0
//│ ╔══[ERROR] Type error in function literal with expected type (List[out <α>58_2]) ->{⊥} ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ║  l.47: 	fun mapi = s =>
//│ ║        	           ^^^^
//│ ║  l.48: 	  region r in
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.49: 	    let i = r.ref 0
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.50: 	    f => map(s) of x =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.51: 	      i := !i + 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.52: 	      f(!i, x)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α74_2 ->{α82_2} List[out α81_2]  <:  ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α82_2) ∨ ⊥  <:  (((⊤ ∧ ⊤) ∧ <α>0_0) ∨ ((⊤ ∧ ⊤) ∧ <α>59_2)) ∨ ⊥
//│ ╟── because: cannot constrain  α82_2  <:  <α>59_2 ∨ <α>0_0
//│ ╟── because: cannot constrain  α83_2  <:  <α>59_2 ∨ <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>59_2 ∨ <α>0_0
//│ ╔══[ERROR] Type error in function literal with expected type (List[out <α>58_2]) ->{⊥} ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ║  l.47: 	fun mapi = s =>
//│ ║        	           ^^^^
//│ ║  l.48: 	  region r in
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.49: 	    let i = r.ref 0
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.50: 	    f => map(s) of x =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.51: 	      i := !i + 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.52: 	      f(!i, x)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α74_2 ->{α82_2} List[out α81_2]  <:  ((Int, <α>58_2) ->{<α>59_2} <α>58_2) ->{<α>0_0 ∨ <α>59_2} List[out <α>58_2]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α82_2) ∨ ⊥  <:  (((⊤ ∧ ⊤) ∧ <α>0_0) ∨ ((⊤ ∧ ⊤) ∧ <α>59_2)) ∨ ⊥
//│ ╟── because: cannot constrain  α82_2  <:  <α>59_2 ∨ <α>0_0
//│ ╟── because: cannot constrain  α83_2  <:  <α>59_2 ∨ <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>59_2 ∨ <α>0_0
//│ Type: ⊤



