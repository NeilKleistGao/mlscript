export declare module Debug3() {
  let z: 1
}
//| 0. Typing TypingUnit(List(let z = 1))
//| | 0. Created lazy type info for let z = 1
//| | Completing let z = 1
//| | | UNSTASHING... (out)
//| | | Type params 
//| | | UNSTASHING... (out)
//| | | Params 
//| | | 0. Typing term 1
//| | | 0. : #1<Int,Num,Object>
//| | | CONSTRAIN #1<Int,Num,Object> <! z2421'
//| | |   where 
//| | | 1. C #1<Int,Num,Object> <! z2421'    (0)
//| | | | NEW z2421' LB (0)
//| | | UNSTASHING... (out)
//| | Completed TypedNuFun(0,let z = 1,#1<Int,Num,Object>) where 
//| | Typing unit statements
//| | : None
//| ⬤ Initial: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| ⬤ Cleaned up: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| consed: Map()
//| ⬤ Unskid: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| analyze1[+] #1<Int,Num,Object>
//| [inv] 
//| [nums] 
//| analyze2[+] #1<Int,Num,Object>
//| [occs] 
//| [vars] TreeSet()
//| [rec] Set()
//| [sub] 
//| [bounds] 
//| [rec] Set()
//| transform[+] #1<Int,Num,Object>   ()  +  None
//| ~> #1<Int,Num,Object>
//| ⬤ Type after simplification: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| normLike[+] TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//| | norm[+] #1<Int,Num,Object>
//| | | DNF: DNF(0, #1<Int,Num,Object>{})
//| | ~> #1<Int,Num,Object>
//| ⬤ Normalized: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| ⬤ Cleaned up: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| consed: Map()
//| ⬤ Unskid: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| analyze1[+] #1<Int,Num,Object>
//| [inv] 
//| [nums] 
//| analyze2[+] #1<Int,Num,Object>
//| [occs] 
//| [vars] TreeSet()
//| [rec] Set()
//| [sub] 
//| [bounds] 
//| [rec] Set()
//| transform[+] #1<Int,Num,Object>   ()  +  None
//| ~> #1<Int,Num,Object>
//| ⬤ Resim: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
//| allVarPols: 
//| [subs] HashMap()
//| ⬤ Factored: TypedTypingUnit(
//|   TypedNuFun(0,let z = 1,#1<Int,Num,Object>)
//|   None)
//|  where: 
