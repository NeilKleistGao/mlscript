export declare module TyperDebug() {
  class A(x: Int) {
    fun add: (y: Int) -> Int
  }
  let aa: A
  unit
}
//| 0. Typing TypingUnit(List(class A(x: Int,) {fun add = (y: Int,) => + (x, y,)}, let aa = A (42,), (console).log ((aa).add (6,),)))
//| | 0. Created lazy type info for class A(x: Int,) {fun add = (y: Int,) => + (x, y,)}
//| | 0. Created lazy type info for let aa = A (42,)
//| | Completing class A(x: Int,) {fun add = (y: Int,) => + (x, y,)}
//| | | UNSTASHING... (out)
//| | | Type params 
//| | | Typing type TypeName(Int)
//| | | | vars=Map() newDefsInfo=Map()
//| | | | 1. type TypeName(Int)
//| | | | => Int
//| | | => Int ——— 
//| | | UNSTASHING... (out)
//| | | Params (x,Int)
//| | | UNSTASHING... (out)
//| | | UNSTASHING... (out)
//| | | 1. Finalizing inheritance with ({} w/ {x: Int} & #A<Object>) <: a815'
//| | | | CONSTRAIN ({} w/ {x: Int} & #A<Object>) <! a815'
//| | | |   where 
//| | | | 1. C ({} w/ {x: Int} & #A<Object>) <! a815'    (0)
//| | | | | NEW a815' LB (0)
//| | | 1. Typing TypingUnit(List(fun add = (y: Int,) => + (x, y,)))
//| | | | 1. Created lazy type info for fun add = (y: Int,) => + (x, y,)
//| | | | Completing fun add = (y: Int,) => + (x, y,)
//| | | | | UNSTASHING... (out)
//| | | | | Type params 
//| | | | | UNSTASHING... (out)
//| | | | | Params 
//| | | | | 2. Typing term (y: Int,) => + (x, y,)
//| | | | | | 2. Typing pattern y: Int,
//| | | | | | | 2. Typing pattern y : Int
//| | | | | | | | Typing type TypeName(Int)
//| | | | | | | | | vars=Map() newDefsInfo=Map()
//| | | | | | | | | 2. type TypeName(Int)
//| | | | | | | | | => Int
//| | | | | | | | => Int ——— 
//| | | | | | | 2. : Int
//| | | | | | 2. : (y: Int,)
//| | | | | | 2. Typing term + (x, y,)
//| | | | | | | 2. Typing term +
//| | | | | | | 2. : ((Int, Int,) -> Int)
//| | | | | | | 2. Typing term x
//| | | | | | | 2. : Int
//| | | | | | | 2. Typing term y
//| | | | | | | 2. : Int
//| | | | | | | CONSTRAIN ((Int, Int,) -> Int) <! ((Int, Int,) -> α816'')
//| | | | | | |   where 
//| | | | | | | 2. C ((Int, Int,) -> Int) <! ((Int, Int,) -> α816'')    (0)
//| | | | | | | | 2. C ((Int, Int,) -> Int) <! ((Int, Int,) -> α816'')    (0)
//| | | | | | | | | 2. C ((Int, Int,) -> Int) <! ((Int, Int,) -> α816'')    (0)
//| | | | | | | | | | 2. C (Int, Int,) <! (Int, Int,)    (1)
//| | | | | | | | | | | Already a subtype by <:<
//| | | | | | | | | | 2. C Int <! α816''    (1)
//| | | | | | | | | | | NEW α816'' LB (0)
//| | | | | | 2. : α816''
//| | | | | 2. : ((y: Int,) -> α816'')
//| | | | | UNSTASHING... (out)
//| | | | | CONSTRAIN ((y: Int,) -> α816'') <! add817''
//| | | | |   where 
//|     α816'' :> Int
//| | | | | 2. C ((y: Int,) -> α816'') <! add817''    (0)
//| | | | | | 2. C ((y: Int,) -> α816'') <! add817''    (0)
//| | | | | | | NEW add817'' LB (2)
//| | | | | UNSTASHING... (out)
//| | | | Completed TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816'')) where 
//|     α816'' :> Int
//| | | | Typing unit statements
//| | | | : None
//| | | Checking base class implementations...
//| | | | (List(),List(TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816''))))
//| | | | UNSTASHING... (out)
//| | | Checking qualifications...
//| | | Checking new implementations...
//| | | | Checking overriding for `add`...
//| | | | Checking overriding for `x`...
//| | | | UNSTASHING... (out)
//| | | UNSTASHING... (out)
//| | | Computing variances of A
//| | | | Trav(+)(({} w/ {x: Int} & #A<Object>))
//| | | | | Trav(+)({} w/ {x: Int})
//| | | | | | Trav(+)(({}\x & {x: Int}))
//| | | | | | | Trav(+)({}\x)
//| | | | | | | | Trav(+)({})
//| | | | | | | Trav(+)({x: Int})
//| | | | | | | | Trav(+)(Int)
//| | | | | Trav(+)(#A<Object>)
//| | | = HashMap()
//| | | UNSTASHING... (out)
//| | Completed TypedNuCls(0, TypeName(A),
//|   List(),
//|   List((x,Int)),
//|   this: ⊤, 
//|   (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816'')))
//|   (x,NuParam(x,Int)),
//|   : ⊤, Set(), Map()) where 
//|     α816'' :> Int
//| | Completing let aa = A (42,)
//| | | UNSTASHING... (out)
//| | | Type params 
//| | | UNSTASHING... (out)
//| | | Params 
//| | | 0. Typing term A (42,)
//| | | | 0. Typing term A
//| | | | 0. : ((x: Int,) -> #A<Object>)
//| | | | 0. Typing term 42
//| | | | 0. : #42<Int,Num,Object>
//| | | | CONSTRAIN ((x: Int,) -> #A<Object>) <! ((#42<Int,Num,Object>,) -> α818)
//| | | |   where 
//| | | | 0. C ((x: Int,) -> #A<Object>) <! ((#42<Int,Num,Object>,) -> α818)    (0)
//| | | | | 0. C ((x: Int,) -> #A<Object>) <! ((#42<Int,Num,Object>,) -> α818)    (0)
//| | | | | | 0. C ((x: Int,) -> #A<Object>) <! ((#42<Int,Num,Object>,) -> α818)    (0)
//| | | | | | | 0. C (#42<Int,Num,Object>,) <! (x: Int,)    (1)
//| | | | | | | | Already a subtype by <:<
//| | | | | | | 0. C #A<Object> <! α818    (1)
//| | | | | | | | NEW α818 LB (0)
//| | | 0. : α818
//| | | CONSTRAIN α818 <! aa819'
//| | |   where 
//|     α818 :> #A<Object>
//| | | 1. C α818 <! aa819'    (0)
//| | | | NEW aa819' LB (0)
//| | | UNSTASHING... (out)
//| | Completed TypedNuFun(0,let aa = A (42,),α818) where 
//|     α818 :> #A<Object>
//| | Typing unit statements
//| | | 0. Typing term (console).log ((aa).add (6,),)
//| | | | 0. Typing term (console).log
//| | | | | 0. Typing term console
//| | | | | 0. : ‹∀ 0. Console›
//| | | | | CONSTRAIN ‹∀ 0. Console› <! {log: log820}
//| | | | |   where 
//| | | | | 0. C ‹∀ 0. Console› <! {log: log820}    (0)
//| | | | | | 0. C ‹∀ 0. Console› <! {log: log820}    (0)
//| | | | | | | 0. C ‹∀ 0. Console› <! {log: log820}    (0)
//| | | | | | | | 0. ARGH  DNF(0, {}∧#Console<>)  <!  DNF(0, {log: log820})
//| | | | | | | | | DNF DISCHARGE CONSTRAINTS
//| | | | | | | | | Consider {}∧#Console<> <: DNF(0, {log: log820})
//| | | | | | | | | Possible: List({log: log820})
//| | | | | | | | | 0. A  {}∧#Console<>  %  List()  <!  List({log: log820})  %  ⊥
//| | | | | | | | | | 0. A  {}∧#Console<>  %  List()  <!  List()  %  {log:log820}
//| | | | | | | | | | | 0. A  {}∧#Console<>  %  List()  <!  List()  %  |{log:log820}
//| | | | | | | | | | | | Looking up field log in None & TreeSet(#Console<>) & {...}
//| | | | | | | | | | | | | Lookup Console.log : Some(((args0: (Anything | MutArray[Anything]),) -> Unit)) where 
//| | | | | | | | | | | | | Fresh[0] Console.log : Some(((args0: (Anything | MutArray[Anything]),) -> Unit)) where Some()
//| | | | | | | | | | | | |   & None  (from refinement)
//| | | | | | | | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! log820    (1)
//| | | | | | | | | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! log820    (1)
//| | | | | | | | | | | | | | NEW log820 LB (0)
//| | | | 0. : log820
//| | | | 0. Typing term (aa).add (6,)
//| | | | | 0. Typing term (aa).add
//| | | | | | 0. Typing term aa
//| | | | | | 0. : α818
//| | | | | | CONSTRAIN α818 <! {add: add821}
//| | | | | |   where 
//|     α818 :> #A<Object>
//| | | | | | 0. C α818 <! {add: add821}    (0)
//| | | | | | | 0. C α818 <! {add: add821}    (0)
//| | | | | | | | 0. C α818 <! {add: add821}    (0)
//| | | | | | | | | NEW α818 UB (0)
//| | | | | | | | | 0. C #A<Object> <! {add: add821}    (2)
//| | | | | | | | | | 0. C #A<Object> <! {add: add821}    (2)
//| | | | | | | | | | | Looking up field add in Some(A) & TreeSet() & {...}
//| | | | | | | | | | | | Lookup A.add : Some(‹∀ 1. ((y: Int,) -> α816'')›) where 
//|     α816'' :> Int
//| | | | | | | | | | | | Fresh[0] A.add : Some(‹∀ 1. ((y: Int,) -> α816'')›) where Some(
//|     α816'' :> Int)
//| | | | | | | | | | | |   & None  (from refinement)
//| | | | | | | | | | | 0. C ‹∀ 1. ((y: Int,) -> α816'')› <! add821    (2)
//| | | | | | | | | | | | NEW add821 LB (0)
//| | | | | 0. : add821
//| | | | | 0. Typing term 6
//| | | | | 0. : #6<Int,Num,Object>
//| | | | | CONSTRAIN add821 <! ((#6<Int,Num,Object>,) -> α822)
//| | | | |   where 
//|     α816'' :> Int
//|     add821 :> ‹∀ 1. ((y: Int,) -> α816'')›
//| | | | | 0. C add821 <! ((#6<Int,Num,Object>,) -> α822)    (0)
//| | | | | | 0. C add821 <! ((#6<Int,Num,Object>,) -> α822)    (0)
//| | | | | | | NEW add821 UB (0)
//| | | | | | | 0. C ‹∀ 1. ((y: Int,) -> α816'')› <! ((#6<Int,Num,Object>,) -> α822)    (2)
//| | | | | | | | 0. C ‹∀ 1. ((y: Int,) -> α816'')› <! ((#6<Int,Num,Object>,) -> α822)    (2)
//| | | | | | | | | 0. C ‹∀ 1. ((y: Int,) -> α816'')› <! ((#6<Int,Num,Object>,) -> α822)    (2)
//| | | | | | | | | | INST [1]   ‹∀ 1. ((y: Int,) -> α816'')›
//| | | | | | | | | |   where  
//|     α816'' :> Int
//| | | | | | | | | | TO [0] ~>  ((y: Int,) -> α816_823)
//| | | | | | | | | |   where  
//|     α816_823 :> Int
//| | | | | | | | | | 0. C ((y: Int,) -> α816_823) <! ((#6<Int,Num,Object>,) -> α822)    (4)
//| | | | | | | | | | | 0. C ((y: Int,) -> α816_823) <! ((#6<Int,Num,Object>,) -> α822)    (4)
//| | | | | | | | | | | | 0. C (#6<Int,Num,Object>,) <! (y: Int,)    (3)
//| | | | | | | | | | | | | Already a subtype by <:<
//| | | | | | | | | | | | 0. C α816_823 <! α822    (3)
//| | | | | | | | | | | | | NEW α816_823 UB (0)
//| | | | | | | | | | | | | 0. C Int <! α822    (6)
//| | | | | | | | | | | | | | 0. C Int <! α822    (6)
//| | | | | | | | | | | | | | | 0. C Int <! α822    (6)
//| | | | | | | | | | | | | | | | NEW α822 LB (0)
//| | | | 0. : α822
//| | | | CONSTRAIN log820 <! ((α822,) -> α824)
//| | | |   where 
//|     log820 :> ((args0: (Anything | MutArray[Anything]),) -> Unit)
//|     α822 :> Int
//| | | | 0. C log820 <! ((α822,) -> α824)    (0)
//| | | | | 0. C log820 <! ((α822,) -> α824)    (0)
//| | | | | | NEW log820 UB (0)
//| | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! ((α822,) -> α824)    (2)
//| | | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! ((α822,) -> α824)    (2)
//| | | | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! ((α822,) -> α824)    (2)
//| | | | | | | | | 0. C ((args0: (Anything | MutArray[Anything]),) -> Unit) <! ((α822,) -> α824)    (2)
//| | | | | | | | | | 0. C (α822,) <! (args0: (Anything | MutArray[Anything]),)    (2)
//| | | | | | | | | | | 0. C (α822,) <! (args0: (Anything | MutArray[Anything]),)    (2)
//| | | | | | | | | | | | 0. C α822 <! (Anything | MutArray[Anything])    (3)
//| | | | | | | | | | | | | NEW α822 UB (0)
//| | | | | | | | | | | | | 0. C Int <! (Anything | MutArray[Anything])    (5)
//| | | | | | | | | | | | | | Already a subtype by <:<
//| | | | | | | | | | 0. C Unit <! α824    (2)
//| | | | | | | | | | | NEW α824 LB (0)
//| | | 0. : α824
//| | : Some(α824)
//| ⬤ Initial: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,Int)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816'')))
//|     (x,NuParam(x,Int)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),α818)
//|   Some(α824))
//|  where: 
//|     α816'' :> Int
//|     α818 :> #A<Object> <: {add: add821}
//|     add821 :> ‹∀ 1. ((y: Int,) -> α816'')› <: ((#6<Int,Num,Object>,) -> α822)
//|     α822 :> Int <: (Anything | MutArray[Anything])
//|     α824 :> Unit
//| allVarPols: +α816'', +α818, +α824
//| Renewed α816'' ~> α816_825''
//| Renewed α818 ~> α818_826
//| Renewed α824 ~> α824_827
//| ⬤ Cleaned up: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,Int)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816_825'')))
//|     (x,NuParam(x,Int)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),α818_826)
//|   Some(α824_827))
//|  where: 
//|     α816_825'' :> Int
//|     α818_826 :> #A<Object>
//|     α824_827 :> Unit
//| allVarPols: +α816_825'', +α818_826, +α824_827
//| consed: Map((true,Int) -> α816_825'', (true,#A<Object>) -> α818_826, (true,Unit) -> α824_827)
//| !unskid-1! Int -> α816_825''
//| !unskid-1! Int -> α816_825''
//| !unskid-1! Int -> α816_825''
//| !unskid-1! #A<Object> -> α818_826
//| ⬤ Unskid: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,α816_825'')),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> α816_825'')))
//|     (x,NuParam(x,α816_825'')),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),α818_826)
//|   Some(α824_827))
//|  where: 
//|     α816_825'' :> Int
//|     α818_826 :> #A<Object>
//|     α824_827 :> Unit
//| analyze1[+] α816_825''
//| | analyze1[+;@[+](0)] Int
//| analyze1[+] ((y: Int,) -> α816_825'')
//| | analyze1[+;-] (y: Int,)
//| | | analyze1[+;-] Int
//| | analyze1[+] α816_825''
//| analyze1[+] α816_825''
//| analyze1[+;-] ⊤
//| analyze1[+;-] ⊤
//| analyze1[+] α818_826
//| | analyze1[+;@[+](0)] #A<Object>
//| analyze1[+] α824_827
//| | analyze1[+;@[+](0)] Unit
//| [inv] 
//| [nums] +α816_825'' 3 ; +α818_826 1 ; +α824_827 1
//| analyze2[+] α816_825''
//| | >> Processing α816_825'' at [+]
//| | go α816_825''   ()
//| | | go Int   (α816_825'')
//| | >> Occurrences HashSet(α816_825'', Int)
//| | >>>> occs[+α816_825''] := HashSet(α816_825'', Int)  <~ None
//| | analyze2[+] Int
//| analyze2[+] ((y: Int,) -> α816_825'')
//| | analyze2[+;-] (y: Int,)
//| | | analyze2[+;-] Int
//| | analyze2[+] α816_825''
//| analyze2[+] α816_825''
//| analyze2[+;-] ⊤
//| analyze2[+;-] ⊤
//| analyze2[+] α818_826
//| | >> Processing α818_826 at [+]
//| | go α818_826   ()
//| | | go #A<Object>   (α818_826)
//| | >> Occurrences HashSet(#A<Object>, α818_826)
//| | >>>> occs[+α818_826] := HashSet(#A<Object>, α818_826)  <~ None
//| | analyze2[+] #A<Object>
//| analyze2[+] α824_827
//| | >> Processing α824_827 at [+]
//| | go α824_827   ()
//| | | go Unit   (α824_827)
//| | >> Occurrences HashSet(Unit, α824_827)
//| | >>>> occs[+α824_827] := HashSet(Unit, α824_827)  <~ None
//| | analyze2[+] Unit
//| [occs] +α816_825'' {α816_825'',Int} ; +α818_826 {#A<Object>,α818_826} ; +α824_827 {Unit,α824_827}
//| [vars] TreeSet(α816_825'', α818_826, α824_827)
//| [rec] Set()
//| 0[1] α818_826
//| 0[1] α824_827
//| 1[!] α816_825''
//| 1[!] α818_826
//| 1[!] α824_827
//| [sub] α816_825'' -> None, α818_826 -> None, α824_827 -> None
//| [bounds] 
//|     α816_825'' :> Int
//|     α818_826 :> #A<Object>
//|     α824_827 :> Unit
//| [rec] Set()
//| transform[+] α816_825''   ()  +  None
//| | -> bound Some(true)
//| | transform[+] Int   (α816_825'')  +;@[+](0)  None
//| | ~> Int
//| ~> Int
//| transform[+] ((y: Int,) -> α816_825'')   ()  +  None
//| | transform[-] (y: Int,)   ()  +;-  None
//| | | transform[-] Int   ()  +;-  None
//| | | ~> Int
//| | ~> (y: Int,)
//| | transform[+] α816_825''   ()  +  None
//| | | -> bound Some(true)
//| | | transform[+] Int   (α816_825'')  +;@[+](0)  None
//| | | ~> Int
//| | ~> Int
//| ~> ((y: Int,) -> Int)
//| transform[+] α816_825''   ()  +  None
//| | -> bound Some(true)
//| | transform[+] Int   (α816_825'')  +;@[+](0)  None
//| | ~> Int
//| ~> Int
//| transform[-] ⊤   ()  +;-  None
//| ~> ⊤
//| transform[+] ⊤   ()  +  None
//| ~> ⊤
//| transform[+] (⊤ w/ {x: α816_825''} & α818_826)   ()  +  None
//| | transform[+] ⊤ w/ {x: α816_825''}   ()  +  None
//| | | transform[+] ⊤   ()  +  None
//| | | ~> ⊤
//| | | transform[+] α816_825''   ()  +  None
//| | | | -> bound Some(true)
//| | | | transform[+] Int   (α816_825'')  +;@[+](0)  None
//| | | | ~> Int
//| | | ~> Int
//| | ~> ⊤ w/ {x: Int}
//| | transform[+] α818_826   ()  +  None
//| | | -> bound Some(true)
//| | | transform[+] #A<Object>   (α818_826)  +;@[+](0)  None
//| | | ~> #A<Object>
//| | ~> #A<Object>
//| ~> (⊤ w/ {x: Int} & #A<Object>)
//| transform[+] α818_826   ()  +  None
//| | -> bound Some(true)
//| | transform[+] #A<Object>   (α818_826)  +;@[+](0)  None
//| | ~> #A<Object>
//| ~> #A<Object>
//| transform[+] α824_827   ()  +  None
//| | -> bound Some(true)
//| | transform[+] Unit   (α824_827)  +;@[+](0)  None
//| | ~> Unit
//| ~> Unit
//| ⬤ Type after simplification: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,Int)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> Int)))
//|     (x,NuParam(x,Int)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),#A<Object>)
//|   Some(Unit))
//|  where: 
//| allVarPols: 
//| normLike[+] TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,Int)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: Int,) -> Int)))
//|     (x,NuParam(x,Int)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),#A<Object>)
//|   Some(Unit))
//| | norm[+] Int
//| | | DNF: DNF(0, #Int<Object,Num>{})
//| | ~> #Int<Object,Num>
//| | norm[+] ((y: Int,) -> Int)
//| | | DNF: DNF(0, ((y: Int,) -> Int){})
//| | | norm[-] (y: Int,)
//| | | | DNF: DNF(0, (y: Int,){})
//| | | | norm[-] Int
//| | | | | DNF: DNF(0, #Int<Object,Num>{})
//| | | | ~> #Int<Object,Num>
//| | | ~> (y: #Int<Object,Num>,)
//| | | norm[+] Int
//| | | | DNF: DNF(0, #Int<Object,Num>{})
//| | | ~> #Int<Object,Num>
//| | ~> ((y: #Int<Object,Num>,) -> #Int<Object,Num>)
//| | norm[+] Int
//| | | DNF: DNF(0, #Int<Object,Num>{})
//| | ~> #Int<Object,Num>
//| | norm[-] ⊤
//| | | DNF: DNF(0, )
//| | ~> ⊤
//| | norm[+] ⊤
//| | | DNF: DNF(0, )
//| | ~> ⊤
//| | norm[+] (⊤ w/ {x: Int} & #A<Object>)
//| | | DNF: DNF(0, #A<Object>{x: Int})
//| | | norm[+] Int
//| | | | DNF: DNF(0, #Int<Object,Num>{})
//| | | ~> #Int<Object,Num>
//| | | rcd2 {x: #Int<Object,Num>}
//| | | typeRef A
//| | | clsFields 
//| | ~> (A & {x: #Int<Object,Num>})
//| | norm[+] #A<Object>
//| | | DNF: DNF(0, #A<Object>{})
//| | | rcd2 {}
//| | | typeRef A
//| | | clsFields 
//| | ~> A
//| | norm[+] Unit
//| | | DNF: DNF(0, #unit<>{})
//| | ~> #unit<>
//| ⬤ Normalized: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,#Int<Object,Num>)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: #Int<Object,Num>,) -> #Int<Object,Num>)))
//|     (x,NuParam(x,#Int<Object,Num>)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),A)
//|   Some(#unit<>))
//|  where: 
//| allVarPols: 
//| ⬤ Cleaned up: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,#Int<Object,Num>)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: #Int<Object,Num>,) -> #Int<Object,Num>)))
//|     (x,NuParam(x,#Int<Object,Num>)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),A)
//|   Some(#unit<>))
//|  where: 
//| allVarPols: 
//| consed: Map()
//| ⬤ Unskid: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,#Int<Object,Num>)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: #Int<Object,Num>,) -> #Int<Object,Num>)))
//|     (x,NuParam(x,#Int<Object,Num>)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),A)
//|   Some(#unit<>))
//|  where: 
//| analyze1[+] #Int<Object,Num>
//| analyze1[+] ((y: #Int<Object,Num>,) -> #Int<Object,Num>)
//| | analyze1[+;-] (y: #Int<Object,Num>,)
//| | | analyze1[+;-] #Int<Object,Num>
//| | analyze1[+] #Int<Object,Num>
//| analyze1[+] #Int<Object,Num>
//| analyze1[+;-] ⊤
//| analyze1[+;-] ⊤
//| analyze1[+] A
//| analyze1[+] #unit<>
//| [inv] 
//| [nums] 
//| analyze2[+] #Int<Object,Num>
//| analyze2[+] ((y: #Int<Object,Num>,) -> #Int<Object,Num>)
//| | analyze2[+;-] (y: #Int<Object,Num>,)
//| | | analyze2[+;-] #Int<Object,Num>
//| | analyze2[+] #Int<Object,Num>
//| analyze2[+] #Int<Object,Num>
//| analyze2[+;-] ⊤
//| analyze2[+;-] ⊤
//| analyze2[+] A
//| analyze2[+] #unit<>
//| [occs] 
//| [vars] TreeSet()
//| [rec] Set()
//| [sub] 
//| [bounds] 
//| [rec] Set()
//| transform[+] #Int<Object,Num>   ()  +  None
//| ~> #Int<Object,Num>
//| transform[+] ((y: #Int<Object,Num>,) -> #Int<Object,Num>)   ()  +  None
//| | transform[-] (y: #Int<Object,Num>,)   ()  +;-  None
//| | | transform[-] #Int<Object,Num>   ()  +;-  None
//| | | ~> #Int<Object,Num>
//| | ~> (y: #Int<Object,Num>,)
//| | transform[+] #Int<Object,Num>   ()  +  None
//| | ~> #Int<Object,Num>
//| ~> ((y: #Int<Object,Num>,) -> #Int<Object,Num>)
//| transform[+] #Int<Object,Num>   ()  +  None
//| ~> #Int<Object,Num>
//| transform[-] ⊤   ()  +;-  None
//| ~> ⊤
//| transform[+] ⊤   ()  +  None
//| ~> ⊤
//| transform[+] (A & {x: #Int<Object,Num>})   ()  +  None
//| | transform[+] A   ()  +  None
//| | ~> A
//| | transform[+] {x: #Int<Object,Num>}   ()  +  None
//| | | transform[+] #Int<Object,Num>   ()  +  None
//| | | ~> #Int<Object,Num>
//| | ~> {x: #Int<Object,Num>}
//| ~> (A & {x: #Int<Object,Num>})
//| transform[+] A   ()  +  None
//| ~> A
//| transform[+] #unit<>   ()  +  None
//| ~> #unit<>
//| ⬤ Resim: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,#Int<Object,Num>)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: #Int<Object,Num>,) -> #Int<Object,Num>)))
//|     (x,NuParam(x,#Int<Object,Num>)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),A)
//|   Some(#unit<>))
//|  where: 
//| allVarPols: 
//| [subs] HashMap()
//| ⬤ Factored: TypedTypingUnit(
//|   TypedNuCls(0, TypeName(A),
//|     List(),
//|     List((x,#Int<Object,Num>)),
//|     this: ⊤, 
//|     (add,TypedNuFun(1,fun add = (y: Int,) => + (x, y,),((y: #Int<Object,Num>,) -> #Int<Object,Num>)))
//|     (x,NuParam(x,#Int<Object,Num>)),
//|     : ⊤, Set(), Map())
//|   TypedNuFun(0,let aa = A (42,),A)
//|   Some(#unit<>))
//|  where: 
