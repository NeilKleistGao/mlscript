// NOTE: This file is autogenerated. Do not modify.
package mlscript.codegen.ast

import mlscript.codegen.{Position => SourcePosition, Location => SourceLocation}
import scala.collection.mutable.{Map => MutMap}

trait Located:
  val start: Option[Int]
  val end: Option[Int]
  val location: Option[SourceLocation]

enum CommentKind:
  case Block
  case Line

/**
 * The syntax tree node for block and line comments.
 *
 * @param value comment text excluding comment delimiters
 * @param start the start index
 * @param end the end index
 * @param loc the location
 * @param ignore generator will skip the comment if `ignore` is true
 */
case class Comment(
  val value: String,
  val start: Option[Int],
  val end: Option[Int],
  val location: Option[SourceLocation],
  val ignore: Option[Boolean]
) extends Located:
  lazy val kind: CommentKind =
    if value contains '\n' then CommentKind.Block else CommentKind.Line

object Comment:
  def apply(value: String): Comment = Comment(value, None, None, None, None)
  def apply(value: String, start: Int, end: Int): Comment = Comment(value, Some(start), Some(end), None, None)

sealed abstract class Node extends Located:
  var leadingComments: Option[List[Comment]] = None
  var innerComments: Option[List[Comment]] = None
  var trailingComments: Option[List[Comment]] = None
  val start: Option[Int]
  val end: Option[Int]
  val location: Option[SourceLocation]
  // val range: Option[(Int, Int)]
  var extra: Option[MutMap[String, Any]] = None

  def compact: Boolean =
    extra match
      case None => false
      case Some(map) => map.get("compact") match
        case Some(compact: Boolean) => compact
        case _ => false

  def compact_=(value: Boolean) =
    (extra.getOrElse {
      val m = MutMap.empty[String, Any]
      extra = Some(m)
      m
    }) += ("compact" -> value)

  def parenthesized: Boolean =
    extra match
      case None => false
      case Some(map) => map.get("parenthesized") match
        case Some(parenthesized: Boolean) => parenthesized
        case _ => false

  def parenthesized_=(value: Boolean) =
    (extra.getOrElse {
      val m = MutMap.empty[String, Any]
      extra = Some(m)
      m
    }) += ("parenthesized" -> value)

enum CommentType:
  case Leading
  case Inner
  case Trailing

/**
 * A cover of AST nodes which are part of an official ECMAScript specification.
 */
trait Standardized

/**
 * A cover of any Expressions.
 */
trait Expression

/**
 * A cover of BinaryExpression and LogicalExpression, which share the same AST shape.
 */
trait Binary:
  val operator: BinaryOperator | LogicalOperator
  val left: Node
  val right: Node

/**
 * A cover of FunctionParent and BlockParent.
 */
trait Scopable

/**
 * A cover of AST nodes that start an execution context with new LexicalEnvironment. In other words, they define the scope of let and const declarations.
 */
trait BlockParent

/**
 * Deprecated. Will be removed in Babel 8.
 */
trait Block

/**
 * A cover of any Statements.
 */
trait Statement

/**
 * A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.
 */
trait Terminatorless

/**
 * A statement that indicates the completion records. In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.
 */
trait CompletionStatement

/**
 * A cover of ConditionalExpression and IfStatement, which share the same AST shape.
 */
trait Conditional:
  val test: Node with Expression

/**
 * A cover of loop statements.
 */
trait Loop

/**
 * A cover of DoWhileStatement and WhileStatement, which share the same AST shape.
 */
trait While

/**
 * A wrapper of expression that does not have runtime semantics.
 */
trait ExpressionWrapper

/**
 * A cover of ForStatements and ForXStatements.
 */
trait For

/**
 * A cover of ForInStatements and ForOfStatements.
 */
trait ForXStatement

/**
 * A cover of functions and methods, the must have body and params. Note: Function is different to FunctionParent. For example, a StaticBlock is a FunctionParent but not Function.
 */
trait Function

/**
 * A cover of AST nodes that start an execution context with new VariableEnvironment. In other words, they define the scope of var declarations.
 */
trait FunctionParent

/**
 * A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.
 */
trait Pureish

/**
 * A cover of any Declarations.
 */
trait Declaration

/**
 * A cover of BindingPatterns.
 */
trait PatternLike

/**
 * A cover of left hand side expressions used in the left of assignment expressions and ForXStatements.
 */
trait LVal

/**
 * A cover of TypeScript entities.
 */
trait TSEntityName

/**
 * A cover of Literals, Regular Expression Literals and Template Literals.
 */
trait Literal

/**
 * A cover of immutable objects and JSX elements. An object is immutable if no other properties can be defined once created.
 */
trait Immutable

/**
 * Deprecated. Will be removed in Babel 8.
 */
trait UserWhitespacable

/**
 * A cover of object methods and class methods.
 */
trait Method

/**
 * A cover of members in an object literal.
 */
trait ObjectMember

/**
 * A cover of object properties and class properties.
 */
trait Property

/**
 * A cover of UnaryExpression and SpreadElement.
 */
trait UnaryLike

/**
 * A cover of BindingPattern except Identifiers.
 */
trait Pattern

/**
 * A cover of ClassExpression and ClassDeclaration, which share the same AST shape.
 */
trait Class:
  val superClass: Option[Node with Expression]

/**
 * A cover of ImportDeclaration and ExportDeclaration
 */
trait ModuleDeclaration

/**
 * A cover of any ExportDeclarations.
 */
trait ExportDeclaration

/**
 * A cover of import and export specifiers. Note: It is not the ModuleSpecifier defined in the spec.
 */
trait ModuleSpecifier

/**
 * Deprecated. Will be removed in Babel 8.
 */
trait Accessor

/**
 * A cover of private class elements and private identifiers.
 */
trait Private

/**
 * A cover of AST nodes defined for Flow.
 */
trait Flow

/**
 * A cover of Flow type annotations.
 */
trait FlowType

/**
 * A cover of primary Flow type annotations.
 */
trait FlowBaseAnnotation

/**
 * A cover of Flow declarations.
 */
trait FlowDeclaration

/**
 * A cover of Flow predicates.
 */
trait FlowPredicate

/**
 * A cover of Flow enum bodies.
 */
trait EnumBody

/**
 * A cover of Flow enum membors.
 */
trait EnumMember

/**
 * A cover of AST nodes defined for JSX.
 */
trait JSX

/**
 * A cover of non-standard AST types that are sometimes useful for development.
 */
trait Miscellaneous

/**
 * A cover of AST nodes defined for TypeScript.
 */
trait TypeScript

/**
 * A cover of TypeScript type declarations.
 */
trait TSTypeElement

/**
 * A cover of TypeScript type annotations.
 */
trait TSType

/**
 * A cover of primary TypeScript type annotations.
 */
trait TSBaseType

case class ArrayExpression(val elements: List[Option[Expression | SpreadElement]] = Nil)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

case class AssignmentExpression(
  val operator: String,
  val left: Node with LVal,
  val right: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression

enum BinaryOperator:
  case Plus
  case Minus
  case Divide
  case Modolus
  case Multiplication
  case Exponentiation
  case BitwiseAnd
  case BitwiseOr
  case BitwiseRightShift
  case BitwiseUnsignedRightShift
  case BitwiseLeftShift
  case BitwiseXor
  case Equal
  case StrictEqual
  case NotEqual
  case StrictNotEqual
  case In
  case InstanceOf
  case GreaterThan
  case LessThan
  case GreaterThanOrEqual
  case LessThanOrEqual
  case Pipeline

case class BinaryExpression(
  val operator: BinaryOperator,
  val left: Node with Expression | PrivateName,
  val right: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Binary with Expression

case class InterpreterDirective(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized

case class Directive(val value: DirectiveLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized

case class DirectiveLiteral(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized

case class BlockStatement(
  val body: List[Node with Statement],
  val directives: List[Directive] = Nil
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with BlockParent with Block with Statement

case class BreakStatement(val label: Option[Identifier] = None)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with Terminatorless with CompletionStatement

case class CallExpression(
  val callee: Node with Expression | Super | V8IntrinsicIdentifier,
  val arguments: List[Node with Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression:
  var optional: Option[Boolean] = None
  var typeArguments: Option[TypeParameterInstantiation] = None
  var typeParameters: Option[TSTypeParameterInstantiation] = None

case class CatchClause(
  val param: Option[Identifier | ArrayPattern | ObjectPattern] = None,
  val body: BlockStatement
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with BlockParent

case class ConditionalExpression(
  val test: Node with Expression,
  val consequent: Node with Expression,
  val alternate: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression with Conditional

case class ContinueStatement(val label: Option[Identifier] = None)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with Terminatorless with CompletionStatement

case class DebuggerStatement()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement

case class DoWhileStatement(val test: Node with Expression, val body: Node with Statement)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with BlockParent with Loop with While with Scopable

case class EmptyStatement()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement

case class ExpressionStatement(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with ExpressionWrapper

case class File(
  val program: Program,
  val comments: Option[List[Comment]] = None,
  val tokens: Option[List[Any]] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized

case class ForInStatement(
  val left: VariableDeclaration | Node with LVal,
  val right: Node with Expression,
  val body: Node with Statement
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Statement with For with BlockParent with Loop with ForXStatement

case class ForStatement(
  val init: Option[VariableDeclaration | Node with Expression] = None,
  val test: Option[Node with Expression] = None,
  val update: Option[Node with Expression] = None,
  val body: Node with Statement
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Statement with For with BlockParent with Loop

case class FunctionDeclaration(
  val id: Option[Identifier] = None,
  val params: List[Identifier | Node with Pattern | RestElement],
  val body: BlockStatement,
  val generator: Boolean = false,
  val async: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Function with BlockParent with FunctionParent with Statement with Pureish with Declaration:
  var declare: Option[Boolean] = None
  var predicate: Option[DeclaredPredicate | InferredPredicate] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class FunctionExpression(
  val id: Option[Identifier] = None,
  val params: List[Identifier | Node with Pattern | RestElement],
  val body: BlockStatement,
  val generator: Boolean = false,
  val async: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Function with BlockParent with FunctionParent with Expression with Pureish:
  var predicate: Option[DeclaredPredicate | InferredPredicate] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class Identifier(val name: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with PatternLike with LVal with TSEntityName:
  var decorators: Option[List[Decorator]] = None
  var optional: Option[Boolean] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None

case class IfStatement(
  val test: Node with Expression,
  val consequent: Node with Statement,
  val alternate: Option[Node with Statement] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement with Conditional

case class LabeledStatement(val label: Identifier, val body: Node with Statement)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement

case class StringLiteral(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal with Immutable

case class NumericLiteral(val value: Int)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal with Immutable

case class NullLiteral()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal with Immutable

case class BooleanLiteral(val value: Boolean)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal with Immutable

case class RegExpLiteral(val pattern: String, val flags: String = "")(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal

enum LogicalOperator:
  case Or
  case And
  case NullishCoalescing

case class LogicalExpression(
  val operator: LogicalOperator,
  val left: Node with Expression,
  val right: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Binary with Expression

case class MemberExpression(
  val `object`: Node with Expression | Super,
  val property: Node with Expression | Identifier | PrivateName,
  val computed: Boolean = false,
  val optional: Option[Boolean] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression with LVal

case class NewExpression(
  val callee: Node with Expression | Super | V8IntrinsicIdentifier,
  val arguments: List[Node with Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression:
  var optional: Option[Boolean] = None
  var typeArguments: Option[TypeParameterInstantiation] = None
  var typeParameters: Option[TSTypeParameterInstantiation] = None

enum SourceType:
  case Script
  case Module

case class Program(
  val body: List[Node with Statement],
  val directives: List[Directive] = Nil,
  val sourceType: SourceType = SourceType.Script,
  val interpreter: Option[InterpreterDirective] = None,
  val sourceFile: String
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with BlockParent with Block

case class ObjectExpression(val properties: List[ObjectMethod | ObjectProperty | SpreadElement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

enum ObjectMethodKind:
  case Method
  case Getter
  case Setter

case class ObjectMethod(
  val kind: Option[ObjectMethodKind] = Some(ObjectMethodKind.Method),
  val key: Node with Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral,
  val params: List[Identifier | Node with Pattern | RestElement],
  val body: BlockStatement,
  val computed: Boolean = false,
  val generator: Boolean = false,
  val async: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with UserWhitespacable with Function with Scopable with BlockParent with FunctionParent with Method with ObjectMember:
  var decorators: Option[List[Decorator]] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class ObjectProperty(
  val key: Node with Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName,
  val value: Node with Expression | Node with PatternLike,
  val computed: Boolean = false,
  val shorthand: Boolean = false,
  val decorators: Option[List[Decorator]] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with UserWhitespacable with Property with ObjectMember

case class RestElement(val argument: Node with LVal)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with LVal with PatternLike:
  var decorators: Option[List[Decorator]] = None
  var optional: Option[Boolean] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None

case class ReturnStatement(val argument: Option[Node with Expression] = None)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with Terminatorless with CompletionStatement

case class SequenceExpression(val expressions: List[Node with Expression])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

case class ParenthesizedExpression(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with ExpressionWrapper

case class SwitchCase(
  val test: Option[Node with Expression] = None,
  val consequent: List[Node with Statement]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized

case class SwitchStatement(val discriminant: Node with Expression, val cases: List[SwitchCase])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with BlockParent with Scopable

case class ThisExpression()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

case class ThrowStatement(val argument: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with Terminatorless with CompletionStatement

case class TryStatement(
  val block: BlockStatement,
  val handler: Option[CatchClause] = None,
  val finalizer: Option[BlockStatement] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement

enum UnaryOperator:
  case Plus
  case Negation
  case LogicalNot
  case BitwiseNot
  case TypeOf
  case Void
  case Delete
  case Throw

case class UnaryExpression(
  val operator: UnaryOperator,
  val argument: Node with Expression,
  val prefix: Boolean = true
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with UnaryLike with Expression

enum UpdateOperator:
  case Increment
  case Decrement

case class UpdateExpression(
  val operator: UpdateOperator,
  val argument: Node with Expression,
  val prefix: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression

enum VariableDeclarationKind:
  case Var
  case Let
  case Const
  case Using

case class VariableDeclaration(
  val kind: VariableDeclarationKind,
  val declarations: List[VariableDeclarator]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement with Declaration:
  var declare: Option[Boolean] = None

case class VariableDeclarator(val id: Node with LVal, val init: Option[Node with Expression] = None)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized:
  var definite: Option[Boolean] = None

case class WhileStatement(val test: Node with Expression, val body: Node with Statement)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with BlockParent with Loop with While with Scopable

case class WithStatement(val `object`: Node with Expression, val body: Node with Statement)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement

case class AssignmentPattern(
  val left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression,
  val right: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Pattern with PatternLike with LVal:
  var decorators: Option[List[Decorator]] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None

case class ArrayPattern(val elements: List[Option[PatternLike | LVal]])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Pattern with PatternLike with LVal:
  var decorators: Option[List[Decorator]] = None
  var optional: Option[Boolean] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None

case class ArrowFunctionExpression(
  val params: List[Identifier | Node with Pattern | RestElement],
  val body: BlockStatement | Node with Expression,
  val async: Boolean = false,
  val expression: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Function with BlockParent with FunctionParent with Expression with Pureish:
  var generator: Option[Boolean] = None
  var predicate: Option[DeclaredPredicate | InferredPredicate] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class ClassBody(
  val body: List[ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized

case class ClassExpression(
  val id: Option[Identifier] = None,
  val superClass: Option[Node with Expression] = None,
  val body: ClassBody,
  val decorators: Option[List[Decorator]] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Class with Expression:
  var implements: Option[List[TSExpressionWithTypeArguments | ClassImplements]] = None
  var mixins: Option[InterfaceExtends] = None
  var superTypeParameters: Option[TypeParameterInstantiation | TSTypeParameterInstantiation] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class ClassDeclaration(
  val id: Identifier,
  val superClass: Option[Node with Expression] = None,
  val body: ClassBody,
  val decorators: Option[List[Decorator]] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Class with Statement with Declaration:
  var `abstract`: Option[Boolean] = None
  var declare: Option[Boolean] = None
  var implements: Option[List[TSExpressionWithTypeArguments | ClassImplements]] = None
  var mixins: Option[InterfaceExtends] = None
  var superTypeParameters: Option[TypeParameterInstantiation | TSTypeParameterInstantiation] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

enum ExportKind:
  case Type
  case Value

case class ExportAllDeclaration(val source: StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Statement with Declaration with ModuleDeclaration with ExportDeclaration:
  var assertions: Option[List[ImportAttribute]] = None
  var exportKind: Option[ExportKind] = None

case class ExportDefaultDeclaration(
  val declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement with Declaration with ModuleDeclaration with ExportDeclaration:
  var exportKind: Option["value"] = None

case class ExportNamedDeclaration(
  val declaration: Option[Node with Declaration] = None,
  val specifiers: List[ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier] = Nil,
  val source: Option[StringLiteral] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement with Declaration with ModuleDeclaration with ExportDeclaration:
  var assertions: Option[List[ImportAttribute]] = None
  var exportKind: Option[ExportKind] = None

case class ExportSpecifier(val local: Identifier, val exported: Identifier | StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with ModuleSpecifier:
  var exportKind: Option[ExportKind] = None

case class ForOfStatement(
  val left: VariableDeclaration | Node with LVal,
  val right: Node with Expression,
  val body: Node with Statement,
  val await: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Scopable with Statement with For with BlockParent with Loop with ForXStatement

enum ImportKind:
  case Type
  case Value
  case TypeOf

case class ImportDeclaration(
  val specifiers: List[ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier],
  val source: StringLiteral
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Statement with Declaration with ModuleDeclaration:
  var assertions: Option[List[ImportAttribute]] = None
  var importKind: Option[ImportKind] = None
  var module: Option[Boolean] = None

case class ImportDefaultSpecifier(val local: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with ModuleSpecifier

case class ImportNamespaceSpecifier(val local: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with ModuleSpecifier

case class ImportSpecifier(val local: Identifier, val imported: Identifier | StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with ModuleSpecifier:
  var importKind: Option[ImportKind] = None

case class MetaProperty(val meta: Identifier, val property: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

enum AccessModifier:
  case Public
  case Private
  case Protected

enum ClassMethodKind:
  case Method
  case Getter
  case Setter
  case Constructor

case class ClassMethod(
  val kind: Option[ClassMethodKind] = Some(ClassMethodKind.Method),
  val key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Node with Expression,
  val params: List[Identifier | Node with Pattern | RestElement | TSParameterProperty],
  val body: BlockStatement,
  val computed: Boolean = false,
  val static: Boolean = false,
  val generator: Boolean = false,
  val async: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Function with Scopable with BlockParent with FunctionParent with Method:
  var `abstract`: Option[Boolean] = None
  var access: Option[AccessModifier] = None
  var accessibility: Option[AccessModifier] = None
  var decorators: Option[List[Decorator]] = None
  var optional: Option[Boolean] = None
  var `override`: Option[Boolean] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class ObjectPattern(val properties: List[RestElement | ObjectProperty])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Pattern with PatternLike with LVal:
  var decorators: Option[List[Decorator]] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None

case class SpreadElement(val argument: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with UnaryLike

case class Super()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

case class TaggedTemplateExpression(val tag: Node with Expression, val quasi: TemplateLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression:
  var typeParameters: Option[TypeParameterInstantiation | TSTypeParameterInstantiation] = None

case class TemplateElement(val value: Any, val tail: Boolean = false)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized

case class TemplateLiteral(
  val quasis: List[TemplateElement],
  val expressions: List[Node with Expression | Node with TSType]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression with Literal

case class YieldExpression(
  val argument: Option[Node with Expression] = None,
  val delegate: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression with Terminatorless

case class AwaitExpression(val argument: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Terminatorless

case class Import()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression

case class BigIntLiteral(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Expression with Pureish with Literal with Immutable

case class ExportNamespaceSpecifier(val exported: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with ModuleSpecifier

case class OptionalMemberExpression(
  val `object`: Node with Expression,
  val property: Node with Expression | Identifier,
  val computed: Option[Boolean] = Some(false),
  val optional: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression

case class OptionalCallExpression(
  val callee: Node with Expression,
  val arguments: List[Node with Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder],
  val optional: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Expression:
  var typeArguments: Option[TypeParameterInstantiation] = None
  var typeParameters: Option[TSTypeParameterInstantiation] = None

case class ClassProperty(
  val key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Node with Expression,
  val value: Option[Node with Expression] = None,
  val typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None,
  val decorators: Option[List[Decorator]] = None,
  val computed: Boolean = false,
  val static: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Property:
  var `abstract`: Option[Boolean] = None
  var accessibility: Option[AccessModifier] = None
  var declare: Option[Boolean] = None
  var definite: Option[Boolean] = None
  var optional: Option[Boolean] = None
  var `override`: Option[Boolean] = None
  var readonly: Option[Boolean] = None
  var variance: Option[Variance] = None

case class ClassAccessorProperty(
  val key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Node with Expression | PrivateName,
  val value: Option[Node with Expression] = None,
  val typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None,
  val decorators: Option[List[Decorator]] = None,
  val computed: Boolean = false,
  val static: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Property with Accessor:
  var `abstract`: Option[Boolean] = None
  var accessibility: Option[AccessModifier] = None
  var declare: Option[Boolean] = None
  var definite: Option[Boolean] = None
  var optional: Option[Boolean] = None
  var `override`: Option[Boolean] = None
  var readonly: Option[Boolean] = None
  var variance: Option[Variance] = None

case class ClassPrivateProperty(
  val key: PrivateName,
  val value: Option[Node with Expression] = None,
  val decorators: Option[List[Decorator]] = None,
  val static: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Property with Private:
  var definite: Option[Boolean] = None
  var readonly: Option[Boolean] = None
  var typeAnnotation: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var variance: Option[Variance] = None

enum ClassPrivateMethodKind:
  case Getter
  case Setter
  case Method

case class ClassPrivateMethod(
  val kind: Option[ClassPrivateMethodKind] = Some(ClassPrivateMethodKind.Method),
  val key: PrivateName,
  val params: List[Identifier | Node with Pattern | RestElement | TSParameterProperty],
  val body: BlockStatement,
  val static: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Standardized with Function with Scopable with BlockParent with FunctionParent with Method with Private:
  var `abstract`: Option[Boolean] = None
  var access: Option[AccessModifier] = None
  var accessibility: Option[AccessModifier] = None
  var async: Option[Boolean] = None
  var computed: Option[Boolean] = None
  var decorators: Option[List[Decorator]] = None
  var generator: Option[Boolean] = None
  var optional: Option[Boolean] = None
  var `override`: Option[Boolean] = None
  var returnType: Option[TypeAnnotation | TSTypeAnnotation | Noop] = None
  var typeParameters: Option[TypeParameterDeclaration | TSTypeParameterDeclaration | Noop] = None

case class PrivateName(val id: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Private

case class StaticBlock(val body: List[Node with Statement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Standardized with Scopable with BlockParent with FunctionParent

case class AnyTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class ArrayTypeAnnotation(val elementType: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class BooleanTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class BooleanLiteralTypeAnnotation(val value: Boolean)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class NullLiteralTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class ClassImplements(
  val id: Identifier,
  val typeParameters: Option[TypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow

case class DeclareClass(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val `extends`: Option[List[InterfaceExtends]] = None,
  val body: ObjectTypeAnnotation
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var implements: Option[List[ClassImplements]] = None
  var mixins: Option[List[InterfaceExtends]] = None

case class DeclareFunction(val id: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var predicate: Option[DeclaredPredicate] = None

case class DeclareInterface(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val `extends`: Option[List[InterfaceExtends]] = None,
  val body: ObjectTypeAnnotation
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var implements: Option[List[ClassImplements]] = None
  var mixins: Option[List[InterfaceExtends]] = None

enum DeclareModuleKind:
  case CommonJS
  case EcmaScript

case class DeclareModule(
  val id: Identifier | StringLiteral,
  val body: BlockStatement,
  val kind: Option[DeclareModuleKind] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration

case class DeclareModuleExports(val typeAnnotation: TypeAnnotation)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowDeclaration with Statement with Declaration

case class DeclareTypeAlias(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val right: Node with FlowType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration

case class DeclareOpaqueType(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val supertype: Option[Node with FlowType] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var impltype: Option[Node with FlowType] = None

case class DeclareVariable(val id: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowDeclaration with Statement with Declaration

case class DeclareExportDeclaration(
  val declaration: Option[Node with Flow] = None,
  val specifiers: Option[List[ExportSpecifier | ExportNamespaceSpecifier]] = None,
  val source: Option[StringLiteral] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var default: Option[Boolean] = None

case class DeclareExportAllDeclaration(val source: StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var exportKind: Option[ExportKind] = None

case class DeclaredPredicate(val value: Node with Flow)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowPredicate

case class ExistsTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class FunctionTypeAnnotation(
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val params: List[FunctionTypeParam],
  val rest: Option[FunctionTypeParam] = None,
  val returnType: Node with FlowType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowType:
  var `this`: Option[FunctionTypeParam] = None

case class FunctionTypeParam(
  val name: Option[Identifier] = None,
  val typeAnnotation: Node with FlowType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow:
  var optional: Option[Boolean] = None

case class GenericTypeAnnotation(
  val id: Identifier | QualifiedTypeIdentifier,
  val typeParameters: Option[TypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowType

case class InferredPredicate()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowPredicate

case class InterfaceExtends(
  val id: Identifier | QualifiedTypeIdentifier,
  val typeParameters: Option[TypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow

case class InterfaceDeclaration(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val `extends`: Option[List[InterfaceExtends]] = None,
  val body: ObjectTypeAnnotation
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration:
  var implements: Option[List[ClassImplements]] = None
  var mixins: Option[List[InterfaceExtends]] = None

case class InterfaceTypeAnnotation(
  val `extends`: Option[List[InterfaceExtends]] = None,
  val body: ObjectTypeAnnotation
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowType

case class IntersectionTypeAnnotation(val types: List[Node with FlowType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class MixedTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class EmptyTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class NullableTypeAnnotation(val typeAnnotation: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class NumberLiteralTypeAnnotation(val value: Int)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class NumberTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class ObjectTypeAnnotation(
  val properties: List[ObjectTypeProperty | ObjectTypeSpreadProperty],
  val indexers: List[ObjectTypeIndexer] = Nil,
  val callProperties: List[ObjectTypeCallProperty] = Nil,
  val internalSlots: List[ObjectTypeInternalSlot] = Nil,
  val exact: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowType:
  var inexact: Option[Boolean] = None

case class ObjectTypeInternalSlot(
  val id: Identifier,
  val value: Node with FlowType,
  val optional: Boolean,
  val static: Boolean,
  val method: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with UserWhitespacable

case class ObjectTypeCallProperty(val value: Node with FlowType, val static: Boolean)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with UserWhitespacable

case class ObjectTypeIndexer(
  val id: Option[Identifier] = None,
  val key: Node with FlowType,
  val value: Node with FlowType,
  val variance: Option[Variance] = None,
  val static: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with UserWhitespacable

enum ObjectTypePropertyKind:
  case Initialization
  case Getter
  case Setter

case class ObjectTypeProperty(
  val key: Identifier | StringLiteral,
  val value: Node with FlowType,
  val variance: Option[Variance] = None,
  val kind: ObjectTypePropertyKind,
  val method: Boolean,
  val optional: Boolean,
  val proto: Boolean,
  val static: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with UserWhitespacable

case class ObjectTypeSpreadProperty(val argument: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with UserWhitespacable

case class OpaqueType(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val supertype: Option[Node with FlowType] = None,
  val impltype: Node with FlowType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration

case class QualifiedTypeIdentifier(
  val id: Identifier,
  val qualification: Identifier | QualifiedTypeIdentifier
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow

case class StringLiteralTypeAnnotation(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class StringTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class SymbolTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class ThisTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class TupleTypeAnnotation(val types: List[Node with FlowType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class TypeofTypeAnnotation(val argument: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class TypeAlias(
  val id: Identifier,
  val typeParameters: Option[TypeParameterDeclaration] = None,
  val right: Node with FlowType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowDeclaration with Statement with Declaration

case class TypeAnnotation(val typeAnnotation: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow

case class TypeCastExpression(
  val expression: Node with Expression,
  val typeAnnotation: TypeAnnotation
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with ExpressionWrapper with Expression

case class TypeParameter(
  val bound: Option[TypeAnnotation] = None,
  val default: Option[Node with FlowType] = None,
  val variance: Option[Variance] = None,
  val name: String
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow

case class TypeParameterDeclaration(val params: List[TypeParameter])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow

case class TypeParameterInstantiation(val params: List[Node with FlowType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow

case class UnionTypeAnnotation(val types: List[Node with FlowType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

enum VarianceKind:
  case Covariant
  case Contravariant

case class Variance(val kind: VarianceKind)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow

case class VoidTypeAnnotation()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType with FlowBaseAnnotation

case class EnumDeclaration(
  val id: Identifier,
  val body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with Statement with Declaration

case class EnumBooleanBody(
  val members: List[EnumBooleanMember],
  val explicitType: Boolean,
  val hasUnknownMembers: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with EnumBody

case class EnumNumberBody(
  val members: List[EnumNumberMember],
  val explicitType: Boolean,
  val hasUnknownMembers: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with EnumBody

case class EnumStringBody(
  val members: List[EnumStringMember | EnumDefaultedMember],
  val explicitType: Boolean,
  val hasUnknownMembers: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with EnumBody

case class EnumSymbolBody(val members: List[EnumDefaultedMember], val hasUnknownMembers: Boolean)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with EnumBody

case class EnumBooleanMember(val id: Identifier, val init: BooleanLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with EnumMember

case class EnumNumberMember(val id: Identifier, val init: NumericLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with EnumMember

case class EnumStringMember(val id: Identifier, val init: StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with EnumMember

case class EnumDefaultedMember(val id: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with EnumMember

case class IndexedAccessType(val objectType: Node with FlowType, val indexType: Node with FlowType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Flow with FlowType

case class OptionalIndexedAccessType(
  val objectType: Node with FlowType,
  val indexType: Node with FlowType,
  val optional: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with Flow with FlowType

case class JSXAttribute(
  val name: JSXIdentifier | JSXNamespacedName,
  val value: Option[JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with JSX with Immutable

case class JSXClosingElement(val name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class JSXElement(
  val openingElement: JSXOpeningElement,
  val closingElement: Option[JSXClosingElement] = None,
  val children: List[JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment],
  val selfClosing: Option[Boolean] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with JSX with Immutable with Expression

case class JSXEmptyExpression()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX

case class JSXExpressionContainer(val expression: Node with Expression | JSXEmptyExpression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class JSXSpreadChild(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class JSXIdentifier(val name: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX

case class JSXMemberExpression(
  val `object`: JSXMemberExpression | JSXIdentifier,
  val property: JSXIdentifier
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with JSX

case class JSXNamespacedName(val namespace: JSXIdentifier, val name: JSXIdentifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX

case class JSXOpeningElement(
  val name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
  val attributes: List[JSXAttribute | JSXSpreadAttribute],
  val selfClosing: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with JSX with Immutable:
  var typeParameters: Option[TypeParameterInstantiation | TSTypeParameterInstantiation] = None

case class JSXSpreadAttribute(val argument: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX

case class JSXText(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class JSXFragment(
  val openingFragment: JSXOpeningFragment,
  val closingFragment: JSXClosingFragment,
  val children: List[JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment]
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with JSX with Immutable with Expression

case class JSXOpeningFragment()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class JSXClosingFragment()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with JSX with Immutable

case class Noop()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Miscellaneous

enum PlaceholderExpectedNode:
  case Identifier
  case StringLiteral
  case Expression
  case Statement
  case Declaration
  case BlockStatement
  case ClassBody
  case Pattern

case class Placeholder(val expectedNode: PlaceholderExpectedNode, val name: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Miscellaneous

case class V8IntrinsicIdentifier(val name: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Miscellaneous

case class ArgumentPlaceholder()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node

case class BindExpression(val `object`: Node with Expression, val callee: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class ImportAttribute(val key: Identifier | StringLiteral, val value: StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node

case class Decorator(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node

case class DoExpression(val body: BlockStatement, val async: Boolean = false)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class ExportDefaultSpecifier(val exported: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with ModuleSpecifier

case class RecordExpression(val properties: List[ObjectProperty | SpreadElement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class TupleExpression(val elements: List[Node with Expression | SpreadElement] = Nil)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class DecimalLiteral(val value: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression with Pureish with Literal with Immutable

case class ModuleExpression(val body: Program)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class TopicReference()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class PipelineTopicExpression(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class PipelineBareFunction(val callee: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class PipelinePrimaryTopicReference()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with Expression

case class TSParameterProperty(val parameter: Identifier | AssignmentPattern)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with LVal:
  var accessibility: Option[AccessModifier] = None
  var decorators: Option[List[Decorator]] = None
  var `override`: Option[Boolean] = None
  var readonly: Option[Boolean] = None

case class TSDeclareFunction(
  val id: Option[Identifier] = None,
  val typeParameters: Option[TSTypeParameterDeclaration | Noop] = None,
  val params: List[Identifier | Node with Pattern | RestElement],
  val returnType: Option[TSTypeAnnotation | Noop] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Statement with Declaration:
  var async: Option[Boolean] = None
  var declare: Option[Boolean] = None
  var generator: Option[Boolean] = None

enum TSDeclareMethodKind:
  case Getter
  case Setter
  case Method
  case Constructor

case class TSDeclareMethod(
  val decorators: Option[List[Decorator]] = None,
  val key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Node with Expression,
  val typeParameters: Option[TSTypeParameterDeclaration | Noop] = None,
  val params: List[Identifier | Node with Pattern | RestElement | TSParameterProperty],
  val returnType: Option[TSTypeAnnotation | Noop] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript:
  var `abstract`: Option[Boolean] = None
  var access: Option[AccessModifier] = None
  var accessibility: Option[AccessModifier] = None
  var async: Option[Boolean] = None
  var computed: Option[Boolean] = None
  var generator: Option[Boolean] = None
  var kind: Option[TSDeclareMethodKind] = None
  var optional: Option[Boolean] = None
  var `override`: Option[Boolean] = None
  var static: Option[Boolean] = None

case class TSQualifiedName(val left: Node with TSEntityName, val right: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSEntityName

case class TSCallSignatureDeclaration(
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val parameters: List[Identifier | RestElement],
  val typeAnnotation: Option[TSTypeAnnotation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSTypeElement

case class TSConstructSignatureDeclaration(
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val parameters: List[Identifier | RestElement],
  val typeAnnotation: Option[TSTypeAnnotation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSTypeElement

enum TSPropertySignatureKind:
  case Getter
  case Setter

case class TSPropertySignature(
  val key: Node with Expression,
  val typeAnnotation: Option[TSTypeAnnotation] = None,
  val initializer: Option[Node with Expression] = None,
  val kind: TSPropertySignatureKind
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSTypeElement:
  var computed: Option[Boolean] = None
  var optional: Option[Boolean] = None
  var readonly: Option[Boolean] = None

enum TSMethodSignatureKind:
  case Method
  case Getter
  case Setter

case class TSMethodSignature(
  val key: Node with Expression,
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val parameters: List[Identifier | RestElement],
  val typeAnnotation: Option[TSTypeAnnotation] = None,
  val kind: TSMethodSignatureKind
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSTypeElement:
  var computed: Option[Boolean] = None
  var optional: Option[Boolean] = None

case class TSIndexSignature(
  val parameters: List[Identifier],
  val typeAnnotation: Option[TSTypeAnnotation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSTypeElement:
  var readonly: Option[Boolean] = None
  var static: Option[Boolean] = None

case class TSAnyKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSBooleanKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSBigIntKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSIntrinsicKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSNeverKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSNullKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSNumberKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSObjectKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSStringKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSSymbolKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSUndefinedKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSUnknownKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSVoidKeyword()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSThisType()(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType with TSBaseType

case class TSFunctionType(
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val parameters: List[Identifier | RestElement],
  val typeAnnotation: Option[TSTypeAnnotation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSConstructorType(
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val parameters: List[Identifier | RestElement],
  val typeAnnotation: Option[TSTypeAnnotation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType:
  var `abstract`: Option[Boolean] = None

case class TSTypeReference(
  val typeName: Node with TSEntityName,
  val typeParameters: Option[TSTypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSTypePredicate(
  val parameterName: Identifier | TSThisType,
  val typeAnnotation: Option[TSTypeAnnotation] = None,
  val asserts: Option[Boolean] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSTypeQuery(
  val exprName: Node with TSEntityName | TSImportType,
  val typeParameters: Option[TSTypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSTypeLiteral(val members: List[Node with TSTypeElement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSArrayType(val elementType: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSTupleType(val elementTypes: List[Node with TSType | TSNamedTupleMember])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSOptionalType(val typeAnnotation: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSRestType(val typeAnnotation: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSNamedTupleMember(
  val label: Identifier,
  val elementType: Node with TSType,
  val optional: Boolean = false
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript

case class TSUnionType(val types: List[Node with TSType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSIntersectionType(val types: List[Node with TSType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSConditionalType(
  val checkType: Node with TSType,
  val extendsType: Node with TSType,
  val trueType: Node with TSType,
  val falseType: Node with TSType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSInferType(val typeParameter: TSTypeParameter)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSParenthesizedType(val typeAnnotation: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSTypeOperator(val typeAnnotation: Node with TSType, val operator: String)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSIndexedAccessType(val objectType: Node with TSType, val indexType: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with TSType

case class TSMappedType(
  val typeParameter: TSTypeParameter,
  val typeAnnotation: Option[Node with TSType] = None,
  val nameType: Option[Node with TSType] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType:
  var optional: Option[true | false | "+" | "-"] = None
  var readonly: Option[true | false | "+" | "-"] = None

case class TSLiteralType(
  val literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType with TSBaseType

case class TSExpressionWithTypeArguments(
  val expression: Node with TSEntityName,
  val typeParameters: Option[TSTypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

case class TSInterfaceDeclaration(
  val id: Identifier,
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val `extends`: Option[List[TSExpressionWithTypeArguments]] = None,
  val body: TSInterfaceBody
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Statement with Declaration:
  var declare: Option[Boolean] = None

case class TSInterfaceBody(val body: List[Node with TSTypeElement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript

case class TSTypeAliasDeclaration(
  val id: Identifier,
  val typeParameters: Option[TSTypeParameterDeclaration] = None,
  val typeAnnotation: Node with TSType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Statement with Declaration:
  var declare: Option[Boolean] = None

case class TSInstantiationExpression(
  val expression: Node with Expression,
  val typeParameters: Option[TSTypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Expression

case class TSAsExpression(
  val expression: Node with Expression,
  val typeAnnotation: Node with TSType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Expression with LVal with PatternLike

case class TSSatisfiesExpression(
  val expression: Node with Expression,
  val typeAnnotation: Node with TSType
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Expression with LVal with PatternLike

case class TSTypeAssertion(
  val typeAnnotation: Node with TSType,
  val expression: Node with Expression
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Expression with LVal with PatternLike

case class TSEnumDeclaration(val id: Identifier, val members: List[TSEnumMember])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with Statement with Declaration:
  var const: Option[Boolean] = None
  var declare: Option[Boolean] = None
  var initializer: Option[Node with Expression] = None

case class TSEnumMember(
  val id: Identifier | StringLiteral,
  val initializer: Option[Node with Expression] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript

case class TSModuleDeclaration(
  val id: Identifier | StringLiteral,
  val body: TSModuleBlock | TSModuleDeclaration
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Statement with Declaration:
  var declare: Option[Boolean] = None
  var global: Option[Boolean] = None

case class TSModuleBlock(val body: List[Node with Statement])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with Scopable with Block with BlockParent with FunctionParent

case class TSImportType(
  val argument: StringLiteral,
  val qualifier: Option[Node with TSEntityName] = None,
  val typeParameters: Option[TSTypeParameterInstantiation] = None
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with TSType

enum TSImportEqualsDeclarationKind:
  case Type
  case Value

case class TSImportEqualsDeclaration(
  val id: Identifier,
  val moduleReference: Node with TSEntityName | TSExternalModuleReference,
  val isExport: Boolean
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript with Statement:
  var importKind: Option[TSImportEqualsDeclarationKind] = None

case class TSExternalModuleReference(val expression: StringLiteral)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript

case class TSNonNullExpression(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with Expression with LVal with PatternLike

case class TSExportAssignment(val expression: Node with Expression)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with Statement

case class TSNamespaceExportDeclaration(val id: Identifier)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript with Statement

case class TSTypeAnnotation(val typeAnnotation: Node with TSType)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript

case class TSTypeParameterInstantiation(val params: List[Node with TSType])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript

case class TSTypeParameterDeclaration(val params: List[TSTypeParameter])(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation])
    extends Node with TypeScript

case class TSTypeParameter(
  val constraint: Option[Node with TSType] = None,
  val default: Option[Node with TSType] = None,
  val name: String
)(val start: Option[Int], val end: Option[Int], val location: Option[SourceLocation]) extends Node with TypeScript:
  var in: Option[Boolean] = None
  var out: Option[Boolean] = None
